// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.19.1
// source: dapr/proto/components/v1/pubsub.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { FeaturesRequest, FeaturesResponse, MetadataRequest, PingRequest, PingResponse } from "./common";

export const protobufPackage = "dapr.proto.components.v1";

/** Used for describing errors when ack'ing messages. */
export interface AckMessageError {
  message: string;
}

/** Used for acknowledge a message. */
export interface PullMessagesRequest {
  /**
   * Required. The subscribed topic for which to initialize the new stream. This
   * must be provided in the first request on the stream, and must not be set in
   * subsequent requests from client to server.
   */
  topic:
    | Topic
    | undefined;
  /** The unique message ID. */
  ackMessageId: string;
  /**
   * Optional, should not be fulfilled when the message was successfully
   * handled.
   */
  ackError: AckMessageError | undefined;
}

/** PubSubInitRequest is the request for initializing the pubsub component. */
export interface PubSubInitRequest {
  /** The metadata request. */
  metadata: MetadataRequest | undefined;
}

/** reserved for future-proof extensibility */
export interface PubSubInitResponse {
}

export interface PublishRequest {
  data: Uint8Array;
  /** The pubsub name. */
  pubsubName: string;
  /** The publishing topic. */
  topic: string;
  /** Message metadata. */
  metadata: { [key: string]: string };
  /** The data content type. */
  contentType: string;
}

export interface PublishRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface BulkPublishRequest {
  entries: BulkMessageEntry[];
  pubsubName: string;
  topic: string;
  metadata: { [key: string]: string };
}

export interface BulkPublishRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface BulkMessageEntry {
  entryId: string;
  event: Uint8Array;
  contentType: string;
  metadata: { [key: string]: string };
}

export interface BulkMessageEntry_MetadataEntry {
  key: string;
  value: string;
}

export interface BulkPublishResponse {
  failedEntries: BulkPublishResponseFailedEntry[];
}

export interface BulkPublishResponseFailedEntry {
  entryId: string;
  error: string;
}

/** reserved for future-proof extensibility */
export interface PublishResponse {
}

export interface Topic {
  /** The topic name desired to be subscribed */
  name: string;
  /** Metadata related subscribe request. */
  metadata: { [key: string]: string };
}

export interface Topic_MetadataEntry {
  key: string;
  value: string;
}

export interface PullMessagesResponse {
  /** The message content. */
  data: Uint8Array;
  /** The topic where the message come from. */
  topicName: string;
  /** The message related metadata. */
  metadata: { [key: string]: string };
  /** The message content type. */
  contentType: string;
  /** The message {transient} ID. Its used for ack'ing it later. */
  id: string;
}

export interface PullMessagesResponse_MetadataEntry {
  key: string;
  value: string;
}

function createBaseAckMessageError(): AckMessageError {
  return { message: "" };
}

export const AckMessageError = {
  encode(message: AckMessageError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AckMessageError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAckMessageError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<AckMessageError, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<AckMessageError | AckMessageError[]> | Iterable<AckMessageError | AckMessageError[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [AckMessageError.encode(p).finish()];
        }
      } else {
        yield* [AckMessageError.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, AckMessageError>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<AckMessageError> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [AckMessageError.decode(p)];
        }
      } else {
        yield* [AckMessageError.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): AckMessageError {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: AckMessageError): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AckMessageError>, I>>(base?: I): AckMessageError {
    return AckMessageError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AckMessageError>, I>>(object: I): AckMessageError {
    const message = createBaseAckMessageError();
    message.message = object.message ?? "";
    return message;
  },
};

function createBasePullMessagesRequest(): PullMessagesRequest {
  return { topic: undefined, ackMessageId: "", ackError: undefined };
}

export const PullMessagesRequest = {
  encode(message: PullMessagesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.topic !== undefined) {
      Topic.encode(message.topic, writer.uint32(10).fork()).ldelim();
    }
    if (message.ackMessageId !== "") {
      writer.uint32(18).string(message.ackMessageId);
    }
    if (message.ackError !== undefined) {
      AckMessageError.encode(message.ackError, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PullMessagesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePullMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = Topic.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ackMessageId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ackError = AckMessageError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PullMessagesRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<PullMessagesRequest | PullMessagesRequest[]>
      | Iterable<PullMessagesRequest | PullMessagesRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PullMessagesRequest.encode(p).finish()];
        }
      } else {
        yield* [PullMessagesRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PullMessagesRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PullMessagesRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PullMessagesRequest.decode(p)];
        }
      } else {
        yield* [PullMessagesRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PullMessagesRequest {
    return {
      topic: isSet(object.topic) ? Topic.fromJSON(object.topic) : undefined,
      ackMessageId: isSet(object.ackMessageId) ? globalThis.String(object.ackMessageId) : "",
      ackError: isSet(object.ackError) ? AckMessageError.fromJSON(object.ackError) : undefined,
    };
  },

  toJSON(message: PullMessagesRequest): unknown {
    const obj: any = {};
    if (message.topic !== undefined) {
      obj.topic = Topic.toJSON(message.topic);
    }
    if (message.ackMessageId !== "") {
      obj.ackMessageId = message.ackMessageId;
    }
    if (message.ackError !== undefined) {
      obj.ackError = AckMessageError.toJSON(message.ackError);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PullMessagesRequest>, I>>(base?: I): PullMessagesRequest {
    return PullMessagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PullMessagesRequest>, I>>(object: I): PullMessagesRequest {
    const message = createBasePullMessagesRequest();
    message.topic = (object.topic !== undefined && object.topic !== null) ? Topic.fromPartial(object.topic) : undefined;
    message.ackMessageId = object.ackMessageId ?? "";
    message.ackError = (object.ackError !== undefined && object.ackError !== null)
      ? AckMessageError.fromPartial(object.ackError)
      : undefined;
    return message;
  },
};

function createBasePubSubInitRequest(): PubSubInitRequest {
  return { metadata: undefined };
}

export const PubSubInitRequest = {
  encode(message: PubSubInitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      MetadataRequest.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PubSubInitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubSubInitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = MetadataRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PubSubInitRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<PubSubInitRequest | PubSubInitRequest[]> | Iterable<PubSubInitRequest | PubSubInitRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PubSubInitRequest.encode(p).finish()];
        }
      } else {
        yield* [PubSubInitRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PubSubInitRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PubSubInitRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PubSubInitRequest.decode(p)];
        }
      } else {
        yield* [PubSubInitRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PubSubInitRequest {
    return { metadata: isSet(object.metadata) ? MetadataRequest.fromJSON(object.metadata) : undefined };
  },

  toJSON(message: PubSubInitRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = MetadataRequest.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubSubInitRequest>, I>>(base?: I): PubSubInitRequest {
    return PubSubInitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubSubInitRequest>, I>>(object: I): PubSubInitRequest {
    const message = createBasePubSubInitRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetadataRequest.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBasePubSubInitResponse(): PubSubInitResponse {
  return {};
}

export const PubSubInitResponse = {
  encode(_: PubSubInitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PubSubInitResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubSubInitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PubSubInitResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<PubSubInitResponse | PubSubInitResponse[]>
      | Iterable<PubSubInitResponse | PubSubInitResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PubSubInitResponse.encode(p).finish()];
        }
      } else {
        yield* [PubSubInitResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PubSubInitResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PubSubInitResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PubSubInitResponse.decode(p)];
        }
      } else {
        yield* [PubSubInitResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): PubSubInitResponse {
    return {};
  },

  toJSON(_: PubSubInitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PubSubInitResponse>, I>>(base?: I): PubSubInitResponse {
    return PubSubInitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubSubInitResponse>, I>>(_: I): PubSubInitResponse {
    const message = createBasePubSubInitResponse();
    return message;
  },
};

function createBasePublishRequest(): PublishRequest {
  return { data: new Uint8Array(0), pubsubName: "", topic: "", metadata: {}, contentType: "" };
}

export const PublishRequest = {
  encode(message: PublishRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.pubsubName !== "") {
      writer.uint32(18).string(message.pubsubName);
    }
    if (message.topic !== "") {
      writer.uint32(26).string(message.topic);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      PublishRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.contentType !== "") {
      writer.uint32(42).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = PublishRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PublishRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<PublishRequest | PublishRequest[]> | Iterable<PublishRequest | PublishRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PublishRequest.encode(p).finish()];
        }
      } else {
        yield* [PublishRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PublishRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PublishRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PublishRequest.decode(p)];
        }
      } else {
        yield* [PublishRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PublishRequest {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: PublishRequest): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishRequest>, I>>(base?: I): PublishRequest {
    return PublishRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishRequest>, I>>(object: I): PublishRequest {
    const message = createBasePublishRequest();
    message.data = object.data ?? new Uint8Array(0);
    message.pubsubName = object.pubsubName ?? "";
    message.topic = object.topic ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBasePublishRequest_MetadataEntry(): PublishRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const PublishRequest_MetadataEntry = {
  encode(message: PublishRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PublishRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<PublishRequest_MetadataEntry | PublishRequest_MetadataEntry[]>
      | Iterable<PublishRequest_MetadataEntry | PublishRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PublishRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [PublishRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PublishRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PublishRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PublishRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [PublishRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PublishRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PublishRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishRequest_MetadataEntry>, I>>(base?: I): PublishRequest_MetadataEntry {
    return PublishRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishRequest_MetadataEntry>, I>>(object: I): PublishRequest_MetadataEntry {
    const message = createBasePublishRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBulkPublishRequest(): BulkPublishRequest {
  return { entries: [], pubsubName: "", topic: "", metadata: {} };
}

export const BulkPublishRequest = {
  encode(message: BulkPublishRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.entries) {
      BulkMessageEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pubsubName !== "") {
      writer.uint32(18).string(message.pubsubName);
    }
    if (message.topic !== "") {
      writer.uint32(26).string(message.topic);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      BulkPublishRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkPublishRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(BulkMessageEntry.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = BulkPublishRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkPublishRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkPublishRequest | BulkPublishRequest[]>
      | Iterable<BulkPublishRequest | BulkPublishRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkPublishRequest.encode(p).finish()];
        }
      } else {
        yield* [BulkPublishRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkPublishRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkPublishRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkPublishRequest.decode(p)];
        }
      } else {
        yield* [BulkPublishRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkPublishRequest {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => BulkMessageEntry.fromJSON(e))
        : [],
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BulkPublishRequest): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => BulkMessageEntry.toJSON(e));
    }
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkPublishRequest>, I>>(base?: I): BulkPublishRequest {
    return BulkPublishRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkPublishRequest>, I>>(object: I): BulkPublishRequest {
    const message = createBaseBulkPublishRequest();
    message.entries = object.entries?.map((e) => BulkMessageEntry.fromPartial(e)) || [];
    message.pubsubName = object.pubsubName ?? "";
    message.topic = object.topic ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBulkPublishRequest_MetadataEntry(): BulkPublishRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const BulkPublishRequest_MetadataEntry = {
  encode(message: BulkPublishRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkPublishRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkPublishRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkPublishRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkPublishRequest_MetadataEntry | BulkPublishRequest_MetadataEntry[]>
      | Iterable<BulkPublishRequest_MetadataEntry | BulkPublishRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkPublishRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [BulkPublishRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkPublishRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkPublishRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkPublishRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [BulkPublishRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkPublishRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BulkPublishRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkPublishRequest_MetadataEntry>, I>>(
    base?: I,
  ): BulkPublishRequest_MetadataEntry {
    return BulkPublishRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkPublishRequest_MetadataEntry>, I>>(
    object: I,
  ): BulkPublishRequest_MetadataEntry {
    const message = createBaseBulkPublishRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBulkMessageEntry(): BulkMessageEntry {
  return { entryId: "", event: new Uint8Array(0), contentType: "", metadata: {} };
}

export const BulkMessageEntry = {
  encode(message: BulkMessageEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entryId !== "") {
      writer.uint32(10).string(message.entryId);
    }
    if (message.event.length !== 0) {
      writer.uint32(18).bytes(message.event);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      BulkMessageEntry_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkMessageEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkMessageEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = BulkMessageEntry_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkMessageEntry, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<BulkMessageEntry | BulkMessageEntry[]> | Iterable<BulkMessageEntry | BulkMessageEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkMessageEntry.encode(p).finish()];
        }
      } else {
        yield* [BulkMessageEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkMessageEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkMessageEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkMessageEntry.decode(p)];
        }
      } else {
        yield* [BulkMessageEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkMessageEntry {
    return {
      entryId: isSet(object.entryId) ? globalThis.String(object.entryId) : "",
      event: isSet(object.event) ? bytesFromBase64(object.event) : new Uint8Array(0),
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BulkMessageEntry): unknown {
    const obj: any = {};
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.event.length !== 0) {
      obj.event = base64FromBytes(message.event);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkMessageEntry>, I>>(base?: I): BulkMessageEntry {
    return BulkMessageEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkMessageEntry>, I>>(object: I): BulkMessageEntry {
    const message = createBaseBulkMessageEntry();
    message.entryId = object.entryId ?? "";
    message.event = object.event ?? new Uint8Array(0);
    message.contentType = object.contentType ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBulkMessageEntry_MetadataEntry(): BulkMessageEntry_MetadataEntry {
  return { key: "", value: "" };
}

export const BulkMessageEntry_MetadataEntry = {
  encode(message: BulkMessageEntry_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkMessageEntry_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkMessageEntry_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkMessageEntry_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkMessageEntry_MetadataEntry | BulkMessageEntry_MetadataEntry[]>
      | Iterable<BulkMessageEntry_MetadataEntry | BulkMessageEntry_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkMessageEntry_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [BulkMessageEntry_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkMessageEntry_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkMessageEntry_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkMessageEntry_MetadataEntry.decode(p)];
        }
      } else {
        yield* [BulkMessageEntry_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkMessageEntry_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BulkMessageEntry_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkMessageEntry_MetadataEntry>, I>>(base?: I): BulkMessageEntry_MetadataEntry {
    return BulkMessageEntry_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkMessageEntry_MetadataEntry>, I>>(
    object: I,
  ): BulkMessageEntry_MetadataEntry {
    const message = createBaseBulkMessageEntry_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBulkPublishResponse(): BulkPublishResponse {
  return { failedEntries: [] };
}

export const BulkPublishResponse = {
  encode(message: BulkPublishResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.failedEntries) {
      BulkPublishResponseFailedEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkPublishResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkPublishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failedEntries.push(BulkPublishResponseFailedEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkPublishResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkPublishResponse | BulkPublishResponse[]>
      | Iterable<BulkPublishResponse | BulkPublishResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkPublishResponse.encode(p).finish()];
        }
      } else {
        yield* [BulkPublishResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkPublishResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkPublishResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkPublishResponse.decode(p)];
        }
      } else {
        yield* [BulkPublishResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkPublishResponse {
    return {
      failedEntries: globalThis.Array.isArray(object?.failedEntries)
        ? object.failedEntries.map((e: any) => BulkPublishResponseFailedEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BulkPublishResponse): unknown {
    const obj: any = {};
    if (message.failedEntries?.length) {
      obj.failedEntries = message.failedEntries.map((e) => BulkPublishResponseFailedEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkPublishResponse>, I>>(base?: I): BulkPublishResponse {
    return BulkPublishResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkPublishResponse>, I>>(object: I): BulkPublishResponse {
    const message = createBaseBulkPublishResponse();
    message.failedEntries = object.failedEntries?.map((e) => BulkPublishResponseFailedEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBulkPublishResponseFailedEntry(): BulkPublishResponseFailedEntry {
  return { entryId: "", error: "" };
}

export const BulkPublishResponseFailedEntry = {
  encode(message: BulkPublishResponseFailedEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entryId !== "") {
      writer.uint32(10).string(message.entryId);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkPublishResponseFailedEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkPublishResponseFailedEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkPublishResponseFailedEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkPublishResponseFailedEntry | BulkPublishResponseFailedEntry[]>
      | Iterable<BulkPublishResponseFailedEntry | BulkPublishResponseFailedEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkPublishResponseFailedEntry.encode(p).finish()];
        }
      } else {
        yield* [BulkPublishResponseFailedEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkPublishResponseFailedEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkPublishResponseFailedEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkPublishResponseFailedEntry.decode(p)];
        }
      } else {
        yield* [BulkPublishResponseFailedEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkPublishResponseFailedEntry {
    return {
      entryId: isSet(object.entryId) ? globalThis.String(object.entryId) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: BulkPublishResponseFailedEntry): unknown {
    const obj: any = {};
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkPublishResponseFailedEntry>, I>>(base?: I): BulkPublishResponseFailedEntry {
    return BulkPublishResponseFailedEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkPublishResponseFailedEntry>, I>>(
    object: I,
  ): BulkPublishResponseFailedEntry {
    const message = createBaseBulkPublishResponseFailedEntry();
    message.entryId = object.entryId ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBasePublishResponse(): PublishResponse {
  return {};
}

export const PublishResponse = {
  encode(_: PublishResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PublishResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<PublishResponse | PublishResponse[]> | Iterable<PublishResponse | PublishResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PublishResponse.encode(p).finish()];
        }
      } else {
        yield* [PublishResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PublishResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PublishResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PublishResponse.decode(p)];
        }
      } else {
        yield* [PublishResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): PublishResponse {
    return {};
  },

  toJSON(_: PublishResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishResponse>, I>>(base?: I): PublishResponse {
    return PublishResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishResponse>, I>>(_: I): PublishResponse {
    const message = createBasePublishResponse();
    return message;
  },
};

function createBaseTopic(): Topic {
  return { name: "", metadata: {} };
}

export const Topic = {
  encode(message: Topic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Topic_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Topic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Topic_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Topic, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Topic | Topic[]> | Iterable<Topic | Topic[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Topic.encode(p).finish()];
        }
      } else {
        yield* [Topic.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Topic>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Topic> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Topic.decode(p)];
        }
      } else {
        yield* [Topic.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Topic {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Topic): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Topic>, I>>(base?: I): Topic {
    return Topic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Topic>, I>>(object: I): Topic {
    const message = createBaseTopic();
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTopic_MetadataEntry(): Topic_MetadataEntry {
  return { key: "", value: "" };
}

export const Topic_MetadataEntry = {
  encode(message: Topic_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Topic_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Topic_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<Topic_MetadataEntry | Topic_MetadataEntry[]>
      | Iterable<Topic_MetadataEntry | Topic_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Topic_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [Topic_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Topic_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Topic_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Topic_MetadataEntry.decode(p)];
        }
      } else {
        yield* [Topic_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Topic_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Topic_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Topic_MetadataEntry>, I>>(base?: I): Topic_MetadataEntry {
    return Topic_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Topic_MetadataEntry>, I>>(object: I): Topic_MetadataEntry {
    const message = createBaseTopic_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePullMessagesResponse(): PullMessagesResponse {
  return { data: new Uint8Array(0), topicName: "", metadata: {}, contentType: "", id: "" };
}

export const PullMessagesResponse = {
  encode(message: PullMessagesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.topicName !== "") {
      writer.uint32(18).string(message.topicName);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      PullMessagesResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PullMessagesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePullMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topicName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = PullMessagesResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PullMessagesResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<PullMessagesResponse | PullMessagesResponse[]>
      | Iterable<PullMessagesResponse | PullMessagesResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PullMessagesResponse.encode(p).finish()];
        }
      } else {
        yield* [PullMessagesResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PullMessagesResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PullMessagesResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PullMessagesResponse.decode(p)];
        }
      } else {
        yield* [PullMessagesResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PullMessagesResponse {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      topicName: isSet(object.topicName) ? globalThis.String(object.topicName) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: PullMessagesResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.topicName !== "") {
      obj.topicName = message.topicName;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PullMessagesResponse>, I>>(base?: I): PullMessagesResponse {
    return PullMessagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PullMessagesResponse>, I>>(object: I): PullMessagesResponse {
    const message = createBasePullMessagesResponse();
    message.data = object.data ?? new Uint8Array(0);
    message.topicName = object.topicName ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.contentType = object.contentType ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBasePullMessagesResponse_MetadataEntry(): PullMessagesResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const PullMessagesResponse_MetadataEntry = {
  encode(message: PullMessagesResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PullMessagesResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePullMessagesResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PullMessagesResponse_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<PullMessagesResponse_MetadataEntry | PullMessagesResponse_MetadataEntry[]>
      | Iterable<PullMessagesResponse_MetadataEntry | PullMessagesResponse_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PullMessagesResponse_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [PullMessagesResponse_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PullMessagesResponse_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PullMessagesResponse_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PullMessagesResponse_MetadataEntry.decode(p)];
        }
      } else {
        yield* [PullMessagesResponse_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PullMessagesResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PullMessagesResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PullMessagesResponse_MetadataEntry>, I>>(
    base?: I,
  ): PullMessagesResponse_MetadataEntry {
    return PullMessagesResponse_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PullMessagesResponse_MetadataEntry>, I>>(
    object: I,
  ): PullMessagesResponse_MetadataEntry {
    const message = createBasePullMessagesResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

/** PubSub service provides a gRPC interface for pubsub components. */
export type PubSubService = typeof PubSubService;
export const PubSubService = {
  /** Initializes the pubsub component with the given metadata. */
  init: {
    path: "/dapr.proto.components.v1.PubSub/Init",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PubSubInitRequest) => Buffer.from(PubSubInitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PubSubInitRequest.decode(value),
    responseSerialize: (value: PubSubInitResponse) => Buffer.from(PubSubInitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PubSubInitResponse.decode(value),
  },
  /** Returns a list of implemented pubsub features. */
  features: {
    path: "/dapr.proto.components.v1.PubSub/Features",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FeaturesRequest) => Buffer.from(FeaturesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FeaturesRequest.decode(value),
    responseSerialize: (value: FeaturesResponse) => Buffer.from(FeaturesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FeaturesResponse.decode(value),
  },
  /** Publish publishes a new message for the given topic. */
  publish: {
    path: "/dapr.proto.components.v1.PubSub/Publish",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PublishRequest) => Buffer.from(PublishRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PublishRequest.decode(value),
    responseSerialize: (value: PublishResponse) => Buffer.from(PublishResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PublishResponse.decode(value),
  },
  bulkPublish: {
    path: "/dapr.proto.components.v1.PubSub/BulkPublish",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BulkPublishRequest) => Buffer.from(BulkPublishRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BulkPublishRequest.decode(value),
    responseSerialize: (value: BulkPublishResponse) => Buffer.from(BulkPublishResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BulkPublishResponse.decode(value),
  },
  /**
   * Establishes a stream with the server (PubSub component), which sends
   * messages down to the client (daprd). The client streams acknowledgements
   * back to the server. The server will close the stream and return the status
   * on any error. In case of closed connection, the client should re-establish
   * the stream. The first message MUST contain a `topic` attribute on it that
   * should be used for the entire streaming pull.
   */
  pullMessages: {
    path: "/dapr.proto.components.v1.PubSub/PullMessages",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: PullMessagesRequest) => Buffer.from(PullMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PullMessagesRequest.decode(value),
    responseSerialize: (value: PullMessagesResponse) => Buffer.from(PullMessagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PullMessagesResponse.decode(value),
  },
  /** Ping the pubsub. Used for liveness porpuses. */
  ping: {
    path: "/dapr.proto.components.v1.PubSub/Ping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PingRequest) => Buffer.from(PingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PingRequest.decode(value),
    responseSerialize: (value: PingResponse) => Buffer.from(PingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PingResponse.decode(value),
  },
} as const;

export interface PubSubServer extends UntypedServiceImplementation {
  /** Initializes the pubsub component with the given metadata. */
  init: handleUnaryCall<PubSubInitRequest, PubSubInitResponse>;
  /** Returns a list of implemented pubsub features. */
  features: handleUnaryCall<FeaturesRequest, FeaturesResponse>;
  /** Publish publishes a new message for the given topic. */
  publish: handleUnaryCall<PublishRequest, PublishResponse>;
  bulkPublish: handleUnaryCall<BulkPublishRequest, BulkPublishResponse>;
  /**
   * Establishes a stream with the server (PubSub component), which sends
   * messages down to the client (daprd). The client streams acknowledgements
   * back to the server. The server will close the stream and return the status
   * on any error. In case of closed connection, the client should re-establish
   * the stream. The first message MUST contain a `topic` attribute on it that
   * should be used for the entire streaming pull.
   */
  pullMessages: handleBidiStreamingCall<PullMessagesRequest, PullMessagesResponse>;
  /** Ping the pubsub. Used for liveness porpuses. */
  ping: handleUnaryCall<PingRequest, PingResponse>;
}

export interface PubSubClient extends Client {
  /** Initializes the pubsub component with the given metadata. */
  init(
    request: PubSubInitRequest,
    callback: (error: ServiceError | null, response: PubSubInitResponse) => void,
  ): ClientUnaryCall;
  init(
    request: PubSubInitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PubSubInitResponse) => void,
  ): ClientUnaryCall;
  init(
    request: PubSubInitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PubSubInitResponse) => void,
  ): ClientUnaryCall;
  /** Returns a list of implemented pubsub features. */
  features(
    request: FeaturesRequest,
    callback: (error: ServiceError | null, response: FeaturesResponse) => void,
  ): ClientUnaryCall;
  features(
    request: FeaturesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: FeaturesResponse) => void,
  ): ClientUnaryCall;
  features(
    request: FeaturesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: FeaturesResponse) => void,
  ): ClientUnaryCall;
  /** Publish publishes a new message for the given topic. */
  publish(
    request: PublishRequest,
    callback: (error: ServiceError | null, response: PublishResponse) => void,
  ): ClientUnaryCall;
  publish(
    request: PublishRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PublishResponse) => void,
  ): ClientUnaryCall;
  publish(
    request: PublishRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PublishResponse) => void,
  ): ClientUnaryCall;
  bulkPublish(
    request: BulkPublishRequest,
    callback: (error: ServiceError | null, response: BulkPublishResponse) => void,
  ): ClientUnaryCall;
  bulkPublish(
    request: BulkPublishRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BulkPublishResponse) => void,
  ): ClientUnaryCall;
  bulkPublish(
    request: BulkPublishRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BulkPublishResponse) => void,
  ): ClientUnaryCall;
  /**
   * Establishes a stream with the server (PubSub component), which sends
   * messages down to the client (daprd). The client streams acknowledgements
   * back to the server. The server will close the stream and return the status
   * on any error. In case of closed connection, the client should re-establish
   * the stream. The first message MUST contain a `topic` attribute on it that
   * should be used for the entire streaming pull.
   */
  pullMessages(): ClientDuplexStream<PullMessagesRequest, PullMessagesResponse>;
  pullMessages(options: Partial<CallOptions>): ClientDuplexStream<PullMessagesRequest, PullMessagesResponse>;
  pullMessages(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<PullMessagesRequest, PullMessagesResponse>;
  /** Ping the pubsub. Used for liveness porpuses. */
  ping(request: PingRequest, callback: (error: ServiceError | null, response: PingResponse) => void): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
}

export const PubSubClient = makeGenericClientConstructor(
  PubSubService,
  "dapr.proto.components.v1.PubSub",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PubSubClient;
  service: typeof PubSubService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
