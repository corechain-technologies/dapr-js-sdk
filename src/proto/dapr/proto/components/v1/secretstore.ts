// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.19.1
// source: dapr/proto/components/v1/secretstore.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { FeaturesRequest, FeaturesResponse, MetadataRequest, PingRequest, PingResponse } from "./common";

export const protobufPackage = "dapr.proto.components.v1";

/** Request to initialize the secret store. */
export interface SecretStoreInitRequest {
  metadata: MetadataRequest | undefined;
}

/** Response from initialization. */
export interface SecretStoreInitResponse {
}

/** GetSecretRequest is the message to get secret from secret store. */
export interface GetSecretRequest {
  /** The name of secret key. */
  key: string;
  /** The metadata which will be sent to secret store components. */
  metadata: { [key: string]: string };
}

export interface GetSecretRequest_MetadataEntry {
  key: string;
  value: string;
}

/** GetSecretResponse is the response message to convey the requested secret. */
export interface GetSecretResponse {
  /**
   * data is the secret value. Some secret store, such as kubernetes secret
   * store, can save multiple secrets for single secret key.
   */
  data: { [key: string]: string };
}

export interface GetSecretResponse_DataEntry {
  key: string;
  value: string;
}

/** BulkGetSecretRequest is the message to get the secrets from secret store. */
export interface BulkGetSecretRequest {
  /** The metadata which will be sent to secret store components. */
  metadata: { [key: string]: string };
}

export interface BulkGetSecretRequest_MetadataEntry {
  key: string;
  value: string;
}

/** SecretResponse is a map of decrypted string/string values */
export interface SecretResponse {
  secrets: { [key: string]: string };
}

export interface SecretResponse_SecretsEntry {
  key: string;
  value: string;
}

/** BulkGetSecretResponse is the response message to convey the requested secrets. */
export interface BulkGetSecretResponse {
  /**
   * data hold the secret values. Some secret store, such as kubernetes secret
   * store, can save multiple secrets for single secret key.
   */
  data: { [key: string]: SecretResponse };
}

export interface BulkGetSecretResponse_DataEntry {
  key: string;
  value: SecretResponse | undefined;
}

function createBaseSecretStoreInitRequest(): SecretStoreInitRequest {
  return { metadata: undefined };
}

export const SecretStoreInitRequest = {
  encode(message: SecretStoreInitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      MetadataRequest.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecretStoreInitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretStoreInitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = MetadataRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecretStoreInitRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<SecretStoreInitRequest | SecretStoreInitRequest[]>
      | Iterable<SecretStoreInitRequest | SecretStoreInitRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecretStoreInitRequest.encode(p).finish()];
        }
      } else {
        yield* [SecretStoreInitRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecretStoreInitRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecretStoreInitRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecretStoreInitRequest.decode(p)];
        }
      } else {
        yield* [SecretStoreInitRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SecretStoreInitRequest {
    return { metadata: isSet(object.metadata) ? MetadataRequest.fromJSON(object.metadata) : undefined };
  },

  toJSON(message: SecretStoreInitRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = MetadataRequest.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretStoreInitRequest>, I>>(base?: I): SecretStoreInitRequest {
    return SecretStoreInitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretStoreInitRequest>, I>>(object: I): SecretStoreInitRequest {
    const message = createBaseSecretStoreInitRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetadataRequest.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseSecretStoreInitResponse(): SecretStoreInitResponse {
  return {};
}

export const SecretStoreInitResponse = {
  encode(_: SecretStoreInitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecretStoreInitResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretStoreInitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecretStoreInitResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<SecretStoreInitResponse | SecretStoreInitResponse[]>
      | Iterable<SecretStoreInitResponse | SecretStoreInitResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecretStoreInitResponse.encode(p).finish()];
        }
      } else {
        yield* [SecretStoreInitResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecretStoreInitResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecretStoreInitResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecretStoreInitResponse.decode(p)];
        }
      } else {
        yield* [SecretStoreInitResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): SecretStoreInitResponse {
    return {};
  },

  toJSON(_: SecretStoreInitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretStoreInitResponse>, I>>(base?: I): SecretStoreInitResponse {
    return SecretStoreInitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretStoreInitResponse>, I>>(_: I): SecretStoreInitResponse {
    const message = createBaseSecretStoreInitResponse();
    return message;
  },
};

function createBaseGetSecretRequest(): GetSecretRequest {
  return { key: "", metadata: {} };
}

export const GetSecretRequest = {
  encode(message: GetSecretRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GetSecretRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSecretRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = GetSecretRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetSecretRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<GetSecretRequest | GetSecretRequest[]> | Iterable<GetSecretRequest | GetSecretRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetSecretRequest.encode(p).finish()];
        }
      } else {
        yield* [GetSecretRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetSecretRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetSecretRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetSecretRequest.decode(p)];
        }
      } else {
        yield* [GetSecretRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetSecretRequest {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetSecretRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSecretRequest>, I>>(base?: I): GetSecretRequest {
    return GetSecretRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSecretRequest>, I>>(object: I): GetSecretRequest {
    const message = createBaseGetSecretRequest();
    message.key = object.key ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetSecretRequest_MetadataEntry(): GetSecretRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const GetSecretRequest_MetadataEntry = {
  encode(message: GetSecretRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSecretRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecretRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetSecretRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<GetSecretRequest_MetadataEntry | GetSecretRequest_MetadataEntry[]>
      | Iterable<GetSecretRequest_MetadataEntry | GetSecretRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetSecretRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [GetSecretRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetSecretRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetSecretRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetSecretRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [GetSecretRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetSecretRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetSecretRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSecretRequest_MetadataEntry>, I>>(base?: I): GetSecretRequest_MetadataEntry {
    return GetSecretRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSecretRequest_MetadataEntry>, I>>(
    object: I,
  ): GetSecretRequest_MetadataEntry {
    const message = createBaseGetSecretRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetSecretResponse(): GetSecretResponse {
  return { data: {} };
}

export const GetSecretResponse = {
  encode(message: GetSecretResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.data).forEach(([key, value]) => {
      GetSecretResponse_DataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSecretResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = GetSecretResponse_DataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.data[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetSecretResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<GetSecretResponse | GetSecretResponse[]> | Iterable<GetSecretResponse | GetSecretResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetSecretResponse.encode(p).finish()];
        }
      } else {
        yield* [GetSecretResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetSecretResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetSecretResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetSecretResponse.decode(p)];
        }
      } else {
        yield* [GetSecretResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetSecretResponse {
    return {
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetSecretResponse): unknown {
    const obj: any = {};
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSecretResponse>, I>>(base?: I): GetSecretResponse {
    return GetSecretResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSecretResponse>, I>>(object: I): GetSecretResponse {
    const message = createBaseGetSecretResponse();
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetSecretResponse_DataEntry(): GetSecretResponse_DataEntry {
  return { key: "", value: "" };
}

export const GetSecretResponse_DataEntry = {
  encode(message: GetSecretResponse_DataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSecretResponse_DataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecretResponse_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetSecretResponse_DataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<GetSecretResponse_DataEntry | GetSecretResponse_DataEntry[]>
      | Iterable<GetSecretResponse_DataEntry | GetSecretResponse_DataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetSecretResponse_DataEntry.encode(p).finish()];
        }
      } else {
        yield* [GetSecretResponse_DataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetSecretResponse_DataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetSecretResponse_DataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetSecretResponse_DataEntry.decode(p)];
        }
      } else {
        yield* [GetSecretResponse_DataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetSecretResponse_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetSecretResponse_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSecretResponse_DataEntry>, I>>(base?: I): GetSecretResponse_DataEntry {
    return GetSecretResponse_DataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSecretResponse_DataEntry>, I>>(object: I): GetSecretResponse_DataEntry {
    const message = createBaseGetSecretResponse_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBulkGetSecretRequest(): BulkGetSecretRequest {
  return { metadata: {} };
}

export const BulkGetSecretRequest = {
  encode(message: BulkGetSecretRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.metadata).forEach(([key, value]) => {
      BulkGetSecretRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkGetSecretRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkGetSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = BulkGetSecretRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.metadata[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkGetSecretRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkGetSecretRequest | BulkGetSecretRequest[]>
      | Iterable<BulkGetSecretRequest | BulkGetSecretRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetSecretRequest.encode(p).finish()];
        }
      } else {
        yield* [BulkGetSecretRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkGetSecretRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkGetSecretRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetSecretRequest.decode(p)];
        }
      } else {
        yield* [BulkGetSecretRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkGetSecretRequest {
    return {
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BulkGetSecretRequest): unknown {
    const obj: any = {};
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkGetSecretRequest>, I>>(base?: I): BulkGetSecretRequest {
    return BulkGetSecretRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkGetSecretRequest>, I>>(object: I): BulkGetSecretRequest {
    const message = createBaseBulkGetSecretRequest();
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBulkGetSecretRequest_MetadataEntry(): BulkGetSecretRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const BulkGetSecretRequest_MetadataEntry = {
  encode(message: BulkGetSecretRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkGetSecretRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkGetSecretRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkGetSecretRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkGetSecretRequest_MetadataEntry | BulkGetSecretRequest_MetadataEntry[]>
      | Iterable<BulkGetSecretRequest_MetadataEntry | BulkGetSecretRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetSecretRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [BulkGetSecretRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkGetSecretRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkGetSecretRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetSecretRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [BulkGetSecretRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkGetSecretRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BulkGetSecretRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkGetSecretRequest_MetadataEntry>, I>>(
    base?: I,
  ): BulkGetSecretRequest_MetadataEntry {
    return BulkGetSecretRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkGetSecretRequest_MetadataEntry>, I>>(
    object: I,
  ): BulkGetSecretRequest_MetadataEntry {
    const message = createBaseBulkGetSecretRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSecretResponse(): SecretResponse {
  return { secrets: {} };
}

export const SecretResponse = {
  encode(message: SecretResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.secrets).forEach(([key, value]) => {
      SecretResponse_SecretsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecretResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = SecretResponse_SecretsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.secrets[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecretResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<SecretResponse | SecretResponse[]> | Iterable<SecretResponse | SecretResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecretResponse.encode(p).finish()];
        }
      } else {
        yield* [SecretResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecretResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecretResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecretResponse.decode(p)];
        }
      } else {
        yield* [SecretResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SecretResponse {
    return {
      secrets: isObject(object.secrets)
        ? Object.entries(object.secrets).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SecretResponse): unknown {
    const obj: any = {};
    if (message.secrets) {
      const entries = Object.entries(message.secrets);
      if (entries.length > 0) {
        obj.secrets = {};
        entries.forEach(([k, v]) => {
          obj.secrets[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretResponse>, I>>(base?: I): SecretResponse {
    return SecretResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretResponse>, I>>(object: I): SecretResponse {
    const message = createBaseSecretResponse();
    message.secrets = Object.entries(object.secrets ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSecretResponse_SecretsEntry(): SecretResponse_SecretsEntry {
  return { key: "", value: "" };
}

export const SecretResponse_SecretsEntry = {
  encode(message: SecretResponse_SecretsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecretResponse_SecretsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretResponse_SecretsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SecretResponse_SecretsEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<SecretResponse_SecretsEntry | SecretResponse_SecretsEntry[]>
      | Iterable<SecretResponse_SecretsEntry | SecretResponse_SecretsEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecretResponse_SecretsEntry.encode(p).finish()];
        }
      } else {
        yield* [SecretResponse_SecretsEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SecretResponse_SecretsEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SecretResponse_SecretsEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SecretResponse_SecretsEntry.decode(p)];
        }
      } else {
        yield* [SecretResponse_SecretsEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SecretResponse_SecretsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SecretResponse_SecretsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretResponse_SecretsEntry>, I>>(base?: I): SecretResponse_SecretsEntry {
    return SecretResponse_SecretsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretResponse_SecretsEntry>, I>>(object: I): SecretResponse_SecretsEntry {
    const message = createBaseSecretResponse_SecretsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBulkGetSecretResponse(): BulkGetSecretResponse {
  return { data: {} };
}

export const BulkGetSecretResponse = {
  encode(message: BulkGetSecretResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.data).forEach(([key, value]) => {
      BulkGetSecretResponse_DataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkGetSecretResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkGetSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = BulkGetSecretResponse_DataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.data[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkGetSecretResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkGetSecretResponse | BulkGetSecretResponse[]>
      | Iterable<BulkGetSecretResponse | BulkGetSecretResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetSecretResponse.encode(p).finish()];
        }
      } else {
        yield* [BulkGetSecretResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkGetSecretResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkGetSecretResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetSecretResponse.decode(p)];
        }
      } else {
        yield* [BulkGetSecretResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkGetSecretResponse {
    return {
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: SecretResponse }>((acc, [key, value]) => {
          acc[key] = SecretResponse.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BulkGetSecretResponse): unknown {
    const obj: any = {};
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = SecretResponse.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkGetSecretResponse>, I>>(base?: I): BulkGetSecretResponse {
    return BulkGetSecretResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkGetSecretResponse>, I>>(object: I): BulkGetSecretResponse {
    const message = createBaseBulkGetSecretResponse();
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: SecretResponse }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SecretResponse.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBulkGetSecretResponse_DataEntry(): BulkGetSecretResponse_DataEntry {
  return { key: "", value: undefined };
}

export const BulkGetSecretResponse_DataEntry = {
  encode(message: BulkGetSecretResponse_DataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SecretResponse.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkGetSecretResponse_DataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkGetSecretResponse_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = SecretResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkGetSecretResponse_DataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkGetSecretResponse_DataEntry | BulkGetSecretResponse_DataEntry[]>
      | Iterable<BulkGetSecretResponse_DataEntry | BulkGetSecretResponse_DataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetSecretResponse_DataEntry.encode(p).finish()];
        }
      } else {
        yield* [BulkGetSecretResponse_DataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkGetSecretResponse_DataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkGetSecretResponse_DataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetSecretResponse_DataEntry.decode(p)];
        }
      } else {
        yield* [BulkGetSecretResponse_DataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkGetSecretResponse_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SecretResponse.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BulkGetSecretResponse_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SecretResponse.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkGetSecretResponse_DataEntry>, I>>(base?: I): BulkGetSecretResponse_DataEntry {
    return BulkGetSecretResponse_DataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkGetSecretResponse_DataEntry>, I>>(
    object: I,
  ): BulkGetSecretResponse_DataEntry {
    const message = createBaseBulkGetSecretResponse_DataEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SecretResponse.fromPartial(object.value)
      : undefined;
    return message;
  },
};

/** Interface for secret store. */
export type SecretStoreService = typeof SecretStoreService;
export const SecretStoreService = {
  /** Initializes the secret store with the given metadata. */
  init: {
    path: "/dapr.proto.components.v1.SecretStore/Init",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SecretStoreInitRequest) => Buffer.from(SecretStoreInitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SecretStoreInitRequest.decode(value),
    responseSerialize: (value: SecretStoreInitResponse) => Buffer.from(SecretStoreInitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SecretStoreInitResponse.decode(value),
  },
  /** Returns a list of implemented secret store features. */
  features: {
    path: "/dapr.proto.components.v1.SecretStore/Features",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FeaturesRequest) => Buffer.from(FeaturesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FeaturesRequest.decode(value),
    responseSerialize: (value: FeaturesResponse) => Buffer.from(FeaturesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FeaturesResponse.decode(value),
  },
  /** Get an individual secret from the store. */
  get: {
    path: "/dapr.proto.components.v1.SecretStore/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSecretRequest) => Buffer.from(GetSecretRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetSecretRequest.decode(value),
    responseSerialize: (value: GetSecretResponse) => Buffer.from(GetSecretResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetSecretResponse.decode(value),
  },
  /** Get all secrets from the store. */
  bulkGet: {
    path: "/dapr.proto.components.v1.SecretStore/BulkGet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BulkGetSecretRequest) => Buffer.from(BulkGetSecretRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BulkGetSecretRequest.decode(value),
    responseSerialize: (value: BulkGetSecretResponse) => Buffer.from(BulkGetSecretResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BulkGetSecretResponse.decode(value),
  },
  /** Ping the pubsub. Used for liveness porpuses. */
  ping: {
    path: "/dapr.proto.components.v1.SecretStore/Ping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PingRequest) => Buffer.from(PingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PingRequest.decode(value),
    responseSerialize: (value: PingResponse) => Buffer.from(PingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PingResponse.decode(value),
  },
} as const;

export interface SecretStoreServer extends UntypedServiceImplementation {
  /** Initializes the secret store with the given metadata. */
  init: handleUnaryCall<SecretStoreInitRequest, SecretStoreInitResponse>;
  /** Returns a list of implemented secret store features. */
  features: handleUnaryCall<FeaturesRequest, FeaturesResponse>;
  /** Get an individual secret from the store. */
  get: handleUnaryCall<GetSecretRequest, GetSecretResponse>;
  /** Get all secrets from the store. */
  bulkGet: handleUnaryCall<BulkGetSecretRequest, BulkGetSecretResponse>;
  /** Ping the pubsub. Used for liveness porpuses. */
  ping: handleUnaryCall<PingRequest, PingResponse>;
}

export interface SecretStoreClient extends Client {
  /** Initializes the secret store with the given metadata. */
  init(
    request: SecretStoreInitRequest,
    callback: (error: ServiceError | null, response: SecretStoreInitResponse) => void,
  ): ClientUnaryCall;
  init(
    request: SecretStoreInitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SecretStoreInitResponse) => void,
  ): ClientUnaryCall;
  init(
    request: SecretStoreInitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SecretStoreInitResponse) => void,
  ): ClientUnaryCall;
  /** Returns a list of implemented secret store features. */
  features(
    request: FeaturesRequest,
    callback: (error: ServiceError | null, response: FeaturesResponse) => void,
  ): ClientUnaryCall;
  features(
    request: FeaturesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: FeaturesResponse) => void,
  ): ClientUnaryCall;
  features(
    request: FeaturesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: FeaturesResponse) => void,
  ): ClientUnaryCall;
  /** Get an individual secret from the store. */
  get(
    request: GetSecretRequest,
    callback: (error: ServiceError | null, response: GetSecretResponse) => void,
  ): ClientUnaryCall;
  get(
    request: GetSecretRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetSecretResponse) => void,
  ): ClientUnaryCall;
  get(
    request: GetSecretRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetSecretResponse) => void,
  ): ClientUnaryCall;
  /** Get all secrets from the store. */
  bulkGet(
    request: BulkGetSecretRequest,
    callback: (error: ServiceError | null, response: BulkGetSecretResponse) => void,
  ): ClientUnaryCall;
  bulkGet(
    request: BulkGetSecretRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BulkGetSecretResponse) => void,
  ): ClientUnaryCall;
  bulkGet(
    request: BulkGetSecretRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BulkGetSecretResponse) => void,
  ): ClientUnaryCall;
  /** Ping the pubsub. Used for liveness porpuses. */
  ping(request: PingRequest, callback: (error: ServiceError | null, response: PingResponse) => void): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
}

export const SecretStoreClient = makeGenericClientConstructor(
  SecretStoreService,
  "dapr.proto.components.v1.SecretStore",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SecretStoreClient;
  service: typeof SecretStoreService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
