// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.19.1
// source: dapr/proto/components/v1/state.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Any } from "../../../../google/protobuf/any";
import { FeaturesRequest, FeaturesResponse, MetadataRequest, PingRequest, PingResponse } from "./common";

export const protobufPackage = "dapr.proto.components.v1";

export interface Sorting {
  /** The key that should be used for sorting. */
  key: string;
  /** The order that should be used. */
  order: Sorting_Order;
}

export enum Sorting_Order {
  ASC = "ASC",
  DESC = "DESC",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function sorting_OrderFromJSON(object: any): Sorting_Order {
  switch (object) {
    case 0:
    case "ASC":
      return Sorting_Order.ASC;
    case 1:
    case "DESC":
      return Sorting_Order.DESC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Sorting_Order.UNRECOGNIZED;
  }
}

export function sorting_OrderToJSON(object: Sorting_Order): string {
  switch (object) {
    case Sorting_Order.ASC:
      return "ASC";
    case Sorting_Order.DESC:
      return "DESC";
    case Sorting_Order.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function sorting_OrderToNumber(object: Sorting_Order): number {
  switch (object) {
    case Sorting_Order.ASC:
      return 0;
    case Sorting_Order.DESC:
      return 1;
    case Sorting_Order.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface Pagination {
  /** Maximum of results that should be returned. */
  limit: Long;
  /** The pagination token. */
  token: string;
}

export interface Query {
  /** Filters that should be applied. */
  filter: { [key: string]: Any };
  /** The sort order. */
  sort: Sorting[];
  /** The query pagination params. */
  pagination: Pagination | undefined;
}

export interface Query_FilterEntry {
  key: string;
  value: Any | undefined;
}

/** QueryRequest is for querying state store. */
export interface QueryRequest {
  /** The query to be performed. */
  query:
    | Query
    | undefined;
  /** Request associated metadata. */
  metadata: { [key: string]: string };
}

export interface QueryRequest_MetadataEntry {
  key: string;
  value: string;
}

/** QueryItem is an object representing a single entry in query results. */
export interface QueryItem {
  /** The returned item Key. */
  key: string;
  /** The returned item Data. */
  data: Uint8Array;
  /** The returned item ETag */
  etag:
    | Etag
    | undefined;
  /** The returned error string. */
  error: string;
  /** The returned contenttype */
  contentType: string;
}

/** QueryResponse is the query response. */
export interface QueryResponse {
  /** The query response items. */
  items: QueryItem[];
  /** The response token. */
  token: string;
  /** Response associated metadata. */
  metadata: { [key: string]: string };
}

export interface QueryResponse_MetadataEntry {
  key: string;
  value: string;
}

/**
 * TransactionalStateOperation describes operation type, key, and value for
 * transactional operation.
 */
export interface TransactionalStateOperation {
  delete?: DeleteRequest | undefined;
  set?: SetRequest | undefined;
}

/**
 * TransactionalStateRequest describes a transactional operation against a state
 * store that comprises multiple types of operations The Request field is either
 * a DeleteRequest or SetRequest.
 */
export interface TransactionalStateRequest {
  /** Operations that should be performed. */
  operations: TransactionalStateOperation[];
  /** Request associated metadata. */
  metadata: { [key: string]: string };
}

export interface TransactionalStateRequest_MetadataEntry {
  key: string;
  value: string;
}

/** reserved for future-proof extensibility */
export interface TransactionalStateResponse {
}

/** Etag represents a state item version */
export interface Etag {
  /** value sets the etag value */
  value: string;
}

/** StateOptions configures concurrency and consistency for state operations */
export interface StateOptions {
  concurrency: StateOptions_StateConcurrency;
  consistency: StateOptions_StateConsistency;
}

/** Enum describing the supported concurrency for state. */
export enum StateOptions_StateConcurrency {
  CONCURRENCY_UNSPECIFIED = "CONCURRENCY_UNSPECIFIED",
  CONCURRENCY_FIRST_WRITE = "CONCURRENCY_FIRST_WRITE",
  CONCURRENCY_LAST_WRITE = "CONCURRENCY_LAST_WRITE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function stateOptions_StateConcurrencyFromJSON(object: any): StateOptions_StateConcurrency {
  switch (object) {
    case 0:
    case "CONCURRENCY_UNSPECIFIED":
      return StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED;
    case 1:
    case "CONCURRENCY_FIRST_WRITE":
      return StateOptions_StateConcurrency.CONCURRENCY_FIRST_WRITE;
    case 2:
    case "CONCURRENCY_LAST_WRITE":
      return StateOptions_StateConcurrency.CONCURRENCY_LAST_WRITE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StateOptions_StateConcurrency.UNRECOGNIZED;
  }
}

export function stateOptions_StateConcurrencyToJSON(object: StateOptions_StateConcurrency): string {
  switch (object) {
    case StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED:
      return "CONCURRENCY_UNSPECIFIED";
    case StateOptions_StateConcurrency.CONCURRENCY_FIRST_WRITE:
      return "CONCURRENCY_FIRST_WRITE";
    case StateOptions_StateConcurrency.CONCURRENCY_LAST_WRITE:
      return "CONCURRENCY_LAST_WRITE";
    case StateOptions_StateConcurrency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function stateOptions_StateConcurrencyToNumber(object: StateOptions_StateConcurrency): number {
  switch (object) {
    case StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED:
      return 0;
    case StateOptions_StateConcurrency.CONCURRENCY_FIRST_WRITE:
      return 1;
    case StateOptions_StateConcurrency.CONCURRENCY_LAST_WRITE:
      return 2;
    case StateOptions_StateConcurrency.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Enum describing the supported consistency for state. */
export enum StateOptions_StateConsistency {
  CONSISTENCY_UNSPECIFIED = "CONSISTENCY_UNSPECIFIED",
  CONSISTENCY_EVENTUAL = "CONSISTENCY_EVENTUAL",
  CONSISTENCY_STRONG = "CONSISTENCY_STRONG",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function stateOptions_StateConsistencyFromJSON(object: any): StateOptions_StateConsistency {
  switch (object) {
    case 0:
    case "CONSISTENCY_UNSPECIFIED":
      return StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED;
    case 1:
    case "CONSISTENCY_EVENTUAL":
      return StateOptions_StateConsistency.CONSISTENCY_EVENTUAL;
    case 2:
    case "CONSISTENCY_STRONG":
      return StateOptions_StateConsistency.CONSISTENCY_STRONG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StateOptions_StateConsistency.UNRECOGNIZED;
  }
}

export function stateOptions_StateConsistencyToJSON(object: StateOptions_StateConsistency): string {
  switch (object) {
    case StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED:
      return "CONSISTENCY_UNSPECIFIED";
    case StateOptions_StateConsistency.CONSISTENCY_EVENTUAL:
      return "CONSISTENCY_EVENTUAL";
    case StateOptions_StateConsistency.CONSISTENCY_STRONG:
      return "CONSISTENCY_STRONG";
    case StateOptions_StateConsistency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function stateOptions_StateConsistencyToNumber(object: StateOptions_StateConsistency): number {
  switch (object) {
    case StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED:
      return 0;
    case StateOptions_StateConsistency.CONSISTENCY_EVENTUAL:
      return 1;
    case StateOptions_StateConsistency.CONSISTENCY_STRONG:
      return 2;
    case StateOptions_StateConsistency.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** InitRequest is the request for initializing the component. */
export interface InitRequest {
  metadata: MetadataRequest | undefined;
}

/** reserved for future-proof extensibility */
export interface InitResponse {
}

export interface GetRequest {
  /** The key that should be retrieved. */
  key: string;
  /** Request associated metadata. */
  metadata: { [key: string]: string };
  /** The get consistency level. */
  consistency: StateOptions_StateConsistency;
}

export interface GetRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface GetResponse {
  /** The data of the GetRequest response. */
  data: Uint8Array;
  /** The etag of the associated key. */
  etag:
    | Etag
    | undefined;
  /** Metadata related to the response. */
  metadata: { [key: string]: string };
  /** The response data contenttype */
  contentType: string;
}

export interface GetResponse_MetadataEntry {
  key: string;
  value: string;
}

export interface DeleteRequest {
  /** The key that should be deleted. */
  key: string;
  /**
   * The etag is used as a If-Match header, to allow certain levels of
   * consistency.
   */
  etag:
    | Etag
    | undefined;
  /** The request metadata. */
  metadata: { [key: string]: string };
  options: StateOptions | undefined;
}

export interface DeleteRequest_MetadataEntry {
  key: string;
  value: string;
}

/** reserved for future-proof extensibility */
export interface DeleteResponse {
}

export interface SetRequest {
  /** The key that should be set. */
  key: string;
  /** Value is the desired content of the given key. */
  value: Uint8Array;
  /**
   * The etag is used as a If-Match header, to allow certain levels of
   * consistency.
   */
  etag:
    | Etag
    | undefined;
  /** The request metadata. */
  metadata: { [key: string]: string };
  /** The Set request options. */
  options:
    | StateOptions
    | undefined;
  /** The data contenttype */
  contentType: string;
}

export interface SetRequest_MetadataEntry {
  key: string;
  value: string;
}

/** reserved for future-proof extensibility */
export interface SetResponse {
}

export interface BulkDeleteRequestOptions {
  parallelism: Long;
}

export interface BulkDeleteRequest {
  items: DeleteRequest[];
  options: BulkDeleteRequestOptions | undefined;
}

/** reserved for future-proof extensibility */
export interface BulkDeleteResponse {
}

export interface BulkGetRequestOptions {
  parallelism: Long;
}

export interface BulkGetRequest {
  items: GetRequest[];
  options: BulkGetRequestOptions | undefined;
}

export interface BulkStateItem {
  /** The key of the fetched item. */
  key: string;
  /** The associated data of the fetched item. */
  data: Uint8Array;
  /** The item ETag */
  etag:
    | Etag
    | undefined;
  /** A fetch error if there's some. */
  error: string;
  /** The State Item metadata. */
  metadata: { [key: string]: string };
  /** The data contenttype */
  contentType: string;
}

export interface BulkStateItem_MetadataEntry {
  key: string;
  value: string;
}

export interface BulkGetResponse {
  items: BulkStateItem[];
}

export interface BulkSetRequestOptions {
  parallelism: Long;
}

export interface BulkSetRequest {
  items: SetRequest[];
  options: BulkSetRequestOptions | undefined;
}

/** reserved for future-proof extensibility */
export interface BulkSetResponse {
}

function createBaseSorting(): Sorting {
  return { key: "", order: Sorting_Order.ASC };
}

export const Sorting = {
  encode(message: Sorting, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.order !== Sorting_Order.ASC) {
      writer.uint32(16).int32(sorting_OrderToNumber(message.order));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Sorting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSorting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.order = sorting_OrderFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Sorting, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Sorting | Sorting[]> | Iterable<Sorting | Sorting[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Sorting.encode(p).finish()];
        }
      } else {
        yield* [Sorting.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Sorting>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Sorting> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Sorting.decode(p)];
        }
      } else {
        yield* [Sorting.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Sorting {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      order: isSet(object.order) ? sorting_OrderFromJSON(object.order) : Sorting_Order.ASC,
    };
  },

  toJSON(message: Sorting): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.order !== Sorting_Order.ASC) {
      obj.order = sorting_OrderToJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Sorting>, I>>(base?: I): Sorting {
    return Sorting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Sorting>, I>>(object: I): Sorting {
    const message = createBaseSorting();
    message.key = object.key ?? "";
    message.order = object.order ?? Sorting_Order.ASC;
    return message;
  },
};

function createBasePagination(): Pagination {
  return { limit: Long.ZERO, token: "" };
}

export const Pagination = {
  encode(message: Pagination, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.limit);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Pagination, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Pagination | Pagination[]> | Iterable<Pagination | Pagination[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Pagination.encode(p).finish()];
        }
      } else {
        yield* [Pagination.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Pagination>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Pagination> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Pagination.decode(p)];
        }
      } else {
        yield* [Pagination.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Pagination {
    return {
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: Pagination): unknown {
    const obj: any = {};
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pagination>, I>>(base?: I): Pagination {
    return Pagination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pagination>, I>>(object: I): Pagination {
    const message = createBasePagination();
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseQuery(): Query {
  return { filter: {}, sort: [], pagination: undefined };
}

export const Query = {
  encode(message: Query, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.filter).forEach(([key, value]) => {
      Query_FilterEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    for (const v of message.sort) {
      Sorting.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Query {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Query_FilterEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.filter[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sort.push(Sorting.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Query, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Query | Query[]> | Iterable<Query | Query[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Query.encode(p).finish()];
        }
      } else {
        yield* [Query.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Query>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Query> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Query.decode(p)];
        }
      } else {
        yield* [Query.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Query {
    return {
      filter: isObject(object.filter)
        ? Object.entries(object.filter).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
          acc[key] = Any.fromJSON(value);
          return acc;
        }, {})
        : {},
      sort: globalThis.Array.isArray(object?.sort) ? object.sort.map((e: any) => Sorting.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: Query): unknown {
    const obj: any = {};
    if (message.filter) {
      const entries = Object.entries(message.filter);
      if (entries.length > 0) {
        obj.filter = {};
        entries.forEach(([k, v]) => {
          obj.filter[k] = Any.toJSON(v);
        });
      }
    }
    if (message.sort?.length) {
      obj.sort = message.sort.map((e) => Sorting.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Query>, I>>(base?: I): Query {
    return Query.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Query>, I>>(object: I): Query {
    const message = createBaseQuery();
    message.filter = Object.entries(object.filter ?? {}).reduce<{ [key: string]: Any }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Any.fromPartial(value);
      }
      return acc;
    }, {});
    message.sort = object.sort?.map((e) => Sorting.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQuery_FilterEntry(): Query_FilterEntry {
  return { key: "", value: undefined };
}

export const Query_FilterEntry = {
  encode(message: Query_FilterEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Query_FilterEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_FilterEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Query_FilterEntry, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Query_FilterEntry | Query_FilterEntry[]> | Iterable<Query_FilterEntry | Query_FilterEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Query_FilterEntry.encode(p).finish()];
        }
      } else {
        yield* [Query_FilterEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Query_FilterEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Query_FilterEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Query_FilterEntry.decode(p)];
        }
      } else {
        yield* [Query_FilterEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Query_FilterEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Query_FilterEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Query_FilterEntry>, I>>(base?: I): Query_FilterEntry {
    return Query_FilterEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Query_FilterEntry>, I>>(object: I): Query_FilterEntry {
    const message = createBaseQuery_FilterEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseQueryRequest(): QueryRequest {
  return { query: undefined, metadata: {} };
}

export const QueryRequest = {
  encode(message: QueryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.query !== undefined) {
      Query.encode(message.query, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      QueryRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = Query.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = QueryRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<QueryRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<QueryRequest | QueryRequest[]> | Iterable<QueryRequest | QueryRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QueryRequest.encode(p).finish()];
        }
      } else {
        yield* [QueryRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, QueryRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<QueryRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QueryRequest.decode(p)];
        }
      } else {
        yield* [QueryRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): QueryRequest {
    return {
      query: isSet(object.query) ? Query.fromJSON(object.query) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: QueryRequest): unknown {
    const obj: any = {};
    if (message.query !== undefined) {
      obj.query = Query.toJSON(message.query);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRequest>, I>>(base?: I): QueryRequest {
    return QueryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRequest>, I>>(object: I): QueryRequest {
    const message = createBaseQueryRequest();
    message.query = (object.query !== undefined && object.query !== null) ? Query.fromPartial(object.query) : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseQueryRequest_MetadataEntry(): QueryRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const QueryRequest_MetadataEntry = {
  encode(message: QueryRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<QueryRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<QueryRequest_MetadataEntry | QueryRequest_MetadataEntry[]>
      | Iterable<QueryRequest_MetadataEntry | QueryRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QueryRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [QueryRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, QueryRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<QueryRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QueryRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [QueryRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): QueryRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: QueryRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRequest_MetadataEntry>, I>>(base?: I): QueryRequest_MetadataEntry {
    return QueryRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRequest_MetadataEntry>, I>>(object: I): QueryRequest_MetadataEntry {
    const message = createBaseQueryRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseQueryItem(): QueryItem {
  return { key: "", data: new Uint8Array(0), etag: undefined, error: "", contentType: "" };
}

export const QueryItem = {
  encode(message: QueryItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.etag !== undefined) {
      Etag.encode(message.etag, writer.uint32(26).fork()).ldelim();
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    if (message.contentType !== "") {
      writer.uint32(42).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = Etag.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<QueryItem, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<QueryItem | QueryItem[]> | Iterable<QueryItem | QueryItem[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QueryItem.encode(p).finish()];
        }
      } else {
        yield* [QueryItem.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, QueryItem>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<QueryItem> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QueryItem.decode(p)];
        }
      } else {
        yield* [QueryItem.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): QueryItem {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      etag: isSet(object.etag) ? Etag.fromJSON(object.etag) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: QueryItem): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.etag !== undefined) {
      obj.etag = Etag.toJSON(message.etag);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryItem>, I>>(base?: I): QueryItem {
    return QueryItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryItem>, I>>(object: I): QueryItem {
    const message = createBaseQueryItem();
    message.key = object.key ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.etag = (object.etag !== undefined && object.etag !== null) ? Etag.fromPartial(object.etag) : undefined;
    message.error = object.error ?? "";
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseQueryResponse(): QueryResponse {
  return { items: [], token: "", metadata: {} };
}

export const QueryResponse = {
  encode(message: QueryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      QueryItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      QueryResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(QueryItem.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = QueryResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<QueryResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<QueryResponse | QueryResponse[]> | Iterable<QueryResponse | QueryResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QueryResponse.encode(p).finish()];
        }
      } else {
        yield* [QueryResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, QueryResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<QueryResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QueryResponse.decode(p)];
        }
      } else {
        yield* [QueryResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): QueryResponse {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => QueryItem.fromJSON(e)) : [],
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: QueryResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => QueryItem.toJSON(e));
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryResponse>, I>>(base?: I): QueryResponse {
    return QueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryResponse>, I>>(object: I): QueryResponse {
    const message = createBaseQueryResponse();
    message.items = object.items?.map((e) => QueryItem.fromPartial(e)) || [];
    message.token = object.token ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseQueryResponse_MetadataEntry(): QueryResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const QueryResponse_MetadataEntry = {
  encode(message: QueryResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<QueryResponse_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<QueryResponse_MetadataEntry | QueryResponse_MetadataEntry[]>
      | Iterable<QueryResponse_MetadataEntry | QueryResponse_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QueryResponse_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [QueryResponse_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, QueryResponse_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<QueryResponse_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [QueryResponse_MetadataEntry.decode(p)];
        }
      } else {
        yield* [QueryResponse_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): QueryResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: QueryResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryResponse_MetadataEntry>, I>>(base?: I): QueryResponse_MetadataEntry {
    return QueryResponse_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryResponse_MetadataEntry>, I>>(object: I): QueryResponse_MetadataEntry {
    const message = createBaseQueryResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTransactionalStateOperation(): TransactionalStateOperation {
  return { delete: undefined, set: undefined };
}

export const TransactionalStateOperation = {
  encode(message: TransactionalStateOperation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.delete !== undefined) {
      DeleteRequest.encode(message.delete, writer.uint32(10).fork()).ldelim();
    }
    if (message.set !== undefined) {
      SetRequest.encode(message.set, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionalStateOperation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionalStateOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.delete = DeleteRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.set = SetRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TransactionalStateOperation, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TransactionalStateOperation | TransactionalStateOperation[]>
      | Iterable<TransactionalStateOperation | TransactionalStateOperation[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TransactionalStateOperation.encode(p).finish()];
        }
      } else {
        yield* [TransactionalStateOperation.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TransactionalStateOperation>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TransactionalStateOperation> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TransactionalStateOperation.decode(p)];
        }
      } else {
        yield* [TransactionalStateOperation.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TransactionalStateOperation {
    return {
      delete: isSet(object.delete) ? DeleteRequest.fromJSON(object.delete) : undefined,
      set: isSet(object.set) ? SetRequest.fromJSON(object.set) : undefined,
    };
  },

  toJSON(message: TransactionalStateOperation): unknown {
    const obj: any = {};
    if (message.delete !== undefined) {
      obj.delete = DeleteRequest.toJSON(message.delete);
    }
    if (message.set !== undefined) {
      obj.set = SetRequest.toJSON(message.set);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionalStateOperation>, I>>(base?: I): TransactionalStateOperation {
    return TransactionalStateOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionalStateOperation>, I>>(object: I): TransactionalStateOperation {
    const message = createBaseTransactionalStateOperation();
    message.delete = (object.delete !== undefined && object.delete !== null)
      ? DeleteRequest.fromPartial(object.delete)
      : undefined;
    message.set = (object.set !== undefined && object.set !== null) ? SetRequest.fromPartial(object.set) : undefined;
    return message;
  },
};

function createBaseTransactionalStateRequest(): TransactionalStateRequest {
  return { operations: [], metadata: {} };
}

export const TransactionalStateRequest = {
  encode(message: TransactionalStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.operations) {
      TransactionalStateOperation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TransactionalStateRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionalStateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionalStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operations.push(TransactionalStateOperation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = TransactionalStateRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TransactionalStateRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TransactionalStateRequest | TransactionalStateRequest[]>
      | Iterable<TransactionalStateRequest | TransactionalStateRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TransactionalStateRequest.encode(p).finish()];
        }
      } else {
        yield* [TransactionalStateRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TransactionalStateRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TransactionalStateRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TransactionalStateRequest.decode(p)];
        }
      } else {
        yield* [TransactionalStateRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TransactionalStateRequest {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => TransactionalStateOperation.fromJSON(e))
        : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TransactionalStateRequest): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => TransactionalStateOperation.toJSON(e));
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionalStateRequest>, I>>(base?: I): TransactionalStateRequest {
    return TransactionalStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionalStateRequest>, I>>(object: I): TransactionalStateRequest {
    const message = createBaseTransactionalStateRequest();
    message.operations = object.operations?.map((e) => TransactionalStateOperation.fromPartial(e)) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTransactionalStateRequest_MetadataEntry(): TransactionalStateRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const TransactionalStateRequest_MetadataEntry = {
  encode(message: TransactionalStateRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionalStateRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionalStateRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TransactionalStateRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TransactionalStateRequest_MetadataEntry | TransactionalStateRequest_MetadataEntry[]>
      | Iterable<TransactionalStateRequest_MetadataEntry | TransactionalStateRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TransactionalStateRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [TransactionalStateRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TransactionalStateRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TransactionalStateRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TransactionalStateRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [TransactionalStateRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TransactionalStateRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TransactionalStateRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionalStateRequest_MetadataEntry>, I>>(
    base?: I,
  ): TransactionalStateRequest_MetadataEntry {
    return TransactionalStateRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionalStateRequest_MetadataEntry>, I>>(
    object: I,
  ): TransactionalStateRequest_MetadataEntry {
    const message = createBaseTransactionalStateRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTransactionalStateResponse(): TransactionalStateResponse {
  return {};
}

export const TransactionalStateResponse = {
  encode(_: TransactionalStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionalStateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionalStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TransactionalStateResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TransactionalStateResponse | TransactionalStateResponse[]>
      | Iterable<TransactionalStateResponse | TransactionalStateResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TransactionalStateResponse.encode(p).finish()];
        }
      } else {
        yield* [TransactionalStateResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TransactionalStateResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TransactionalStateResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TransactionalStateResponse.decode(p)];
        }
      } else {
        yield* [TransactionalStateResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): TransactionalStateResponse {
    return {};
  },

  toJSON(_: TransactionalStateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionalStateResponse>, I>>(base?: I): TransactionalStateResponse {
    return TransactionalStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionalStateResponse>, I>>(_: I): TransactionalStateResponse {
    const message = createBaseTransactionalStateResponse();
    return message;
  },
};

function createBaseEtag(): Etag {
  return { value: "" };
}

export const Etag = {
  encode(message: Etag, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Etag {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEtag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Etag, Uint8Array>
  async *encodeTransform(source: AsyncIterable<Etag | Etag[]> | Iterable<Etag | Etag[]>): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Etag.encode(p).finish()];
        }
      } else {
        yield* [Etag.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Etag>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Etag> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Etag.decode(p)];
        }
      } else {
        yield* [Etag.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Etag {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: Etag): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Etag>, I>>(base?: I): Etag {
    return Etag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Etag>, I>>(object: I): Etag {
    const message = createBaseEtag();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStateOptions(): StateOptions {
  return {
    concurrency: StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED,
    consistency: StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED,
  };
}

export const StateOptions = {
  encode(message: StateOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.concurrency !== StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED) {
      writer.uint32(8).int32(stateOptions_StateConcurrencyToNumber(message.concurrency));
    }
    if (message.consistency !== StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED) {
      writer.uint32(16).int32(stateOptions_StateConsistencyToNumber(message.consistency));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StateOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.concurrency = stateOptions_StateConcurrencyFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.consistency = stateOptions_StateConsistencyFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<StateOptions, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<StateOptions | StateOptions[]> | Iterable<StateOptions | StateOptions[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [StateOptions.encode(p).finish()];
        }
      } else {
        yield* [StateOptions.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, StateOptions>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<StateOptions> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [StateOptions.decode(p)];
        }
      } else {
        yield* [StateOptions.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): StateOptions {
    return {
      concurrency: isSet(object.concurrency)
        ? stateOptions_StateConcurrencyFromJSON(object.concurrency)
        : StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED,
      consistency: isSet(object.consistency)
        ? stateOptions_StateConsistencyFromJSON(object.consistency)
        : StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED,
    };
  },

  toJSON(message: StateOptions): unknown {
    const obj: any = {};
    if (message.concurrency !== StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED) {
      obj.concurrency = stateOptions_StateConcurrencyToJSON(message.concurrency);
    }
    if (message.consistency !== StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED) {
      obj.consistency = stateOptions_StateConsistencyToJSON(message.consistency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StateOptions>, I>>(base?: I): StateOptions {
    return StateOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateOptions>, I>>(object: I): StateOptions {
    const message = createBaseStateOptions();
    message.concurrency = object.concurrency ?? StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED;
    message.consistency = object.consistency ?? StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED;
    return message;
  },
};

function createBaseInitRequest(): InitRequest {
  return { metadata: undefined };
}

export const InitRequest = {
  encode(message: InitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      MetadataRequest.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = MetadataRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InitRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<InitRequest | InitRequest[]> | Iterable<InitRequest | InitRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InitRequest.encode(p).finish()];
        }
      } else {
        yield* [InitRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InitRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InitRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InitRequest.decode(p)];
        }
      } else {
        yield* [InitRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InitRequest {
    return { metadata: isSet(object.metadata) ? MetadataRequest.fromJSON(object.metadata) : undefined };
  },

  toJSON(message: InitRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = MetadataRequest.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitRequest>, I>>(base?: I): InitRequest {
    return InitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitRequest>, I>>(object: I): InitRequest {
    const message = createBaseInitRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetadataRequest.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseInitResponse(): InitResponse {
  return {};
}

export const InitResponse = {
  encode(_: InitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InitResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<InitResponse | InitResponse[]> | Iterable<InitResponse | InitResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InitResponse.encode(p).finish()];
        }
      } else {
        yield* [InitResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InitResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InitResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InitResponse.decode(p)];
        }
      } else {
        yield* [InitResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): InitResponse {
    return {};
  },

  toJSON(_: InitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<InitResponse>, I>>(base?: I): InitResponse {
    return InitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitResponse>, I>>(_: I): InitResponse {
    const message = createBaseInitResponse();
    return message;
  },
};

function createBaseGetRequest(): GetRequest {
  return { key: "", metadata: {}, consistency: StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED };
}

export const GetRequest = {
  encode(message: GetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GetRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.consistency !== StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED) {
      writer.uint32(24).int32(stateOptions_StateConsistencyToNumber(message.consistency));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = GetRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.consistency = stateOptions_StateConsistencyFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<GetRequest | GetRequest[]> | Iterable<GetRequest | GetRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetRequest.encode(p).finish()];
        }
      } else {
        yield* [GetRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetRequest.decode(p)];
        }
      } else {
        yield* [GetRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetRequest {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      consistency: isSet(object.consistency)
        ? stateOptions_StateConsistencyFromJSON(object.consistency)
        : StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED,
    };
  },

  toJSON(message: GetRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.consistency !== StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED) {
      obj.consistency = stateOptions_StateConsistencyToJSON(message.consistency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRequest>, I>>(base?: I): GetRequest {
    return GetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRequest>, I>>(object: I): GetRequest {
    const message = createBaseGetRequest();
    message.key = object.key ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.consistency = object.consistency ?? StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED;
    return message;
  },
};

function createBaseGetRequest_MetadataEntry(): GetRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const GetRequest_MetadataEntry = {
  encode(message: GetRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<GetRequest_MetadataEntry | GetRequest_MetadataEntry[]>
      | Iterable<GetRequest_MetadataEntry | GetRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [GetRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [GetRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRequest_MetadataEntry>, I>>(base?: I): GetRequest_MetadataEntry {
    return GetRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRequest_MetadataEntry>, I>>(object: I): GetRequest_MetadataEntry {
    const message = createBaseGetRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetResponse(): GetResponse {
  return { data: new Uint8Array(0), etag: undefined, metadata: {}, contentType: "" };
}

export const GetResponse = {
  encode(message: GetResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.etag !== undefined) {
      Etag.encode(message.etag, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GetResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = Etag.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = GetResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<GetResponse | GetResponse[]> | Iterable<GetResponse | GetResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetResponse.encode(p).finish()];
        }
      } else {
        yield* [GetResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetResponse.decode(p)];
        }
      } else {
        yield* [GetResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetResponse {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      etag: isSet(object.etag) ? Etag.fromJSON(object.etag) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: GetResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.etag !== undefined) {
      obj.etag = Etag.toJSON(message.etag);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResponse>, I>>(base?: I): GetResponse {
    return GetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResponse>, I>>(object: I): GetResponse {
    const message = createBaseGetResponse();
    message.data = object.data ?? new Uint8Array(0);
    message.etag = (object.etag !== undefined && object.etag !== null) ? Etag.fromPartial(object.etag) : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseGetResponse_MetadataEntry(): GetResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const GetResponse_MetadataEntry = {
  encode(message: GetResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetResponse_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<GetResponse_MetadataEntry | GetResponse_MetadataEntry[]>
      | Iterable<GetResponse_MetadataEntry | GetResponse_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetResponse_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [GetResponse_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetResponse_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetResponse_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetResponse_MetadataEntry.decode(p)];
        }
      } else {
        yield* [GetResponse_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResponse_MetadataEntry>, I>>(base?: I): GetResponse_MetadataEntry {
    return GetResponse_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResponse_MetadataEntry>, I>>(object: I): GetResponse_MetadataEntry {
    const message = createBaseGetResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeleteRequest(): DeleteRequest {
  return { key: "", etag: undefined, metadata: {}, options: undefined };
}

export const DeleteRequest = {
  encode(message: DeleteRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.etag !== undefined) {
      Etag.encode(message.etag, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      DeleteRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.options !== undefined) {
      StateOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = Etag.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = DeleteRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.options = StateOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<DeleteRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<DeleteRequest | DeleteRequest[]> | Iterable<DeleteRequest | DeleteRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [DeleteRequest.encode(p).finish()];
        }
      } else {
        yield* [DeleteRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, DeleteRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<DeleteRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [DeleteRequest.decode(p)];
        }
      } else {
        yield* [DeleteRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): DeleteRequest {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      etag: isSet(object.etag) ? Etag.fromJSON(object.etag) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      options: isSet(object.options) ? StateOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: DeleteRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.etag !== undefined) {
      obj.etag = Etag.toJSON(message.etag);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.options !== undefined) {
      obj.options = StateOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRequest>, I>>(base?: I): DeleteRequest {
    return DeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRequest>, I>>(object: I): DeleteRequest {
    const message = createBaseDeleteRequest();
    message.key = object.key ?? "";
    message.etag = (object.etag !== undefined && object.etag !== null) ? Etag.fromPartial(object.etag) : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.options = (object.options !== undefined && object.options !== null)
      ? StateOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseDeleteRequest_MetadataEntry(): DeleteRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const DeleteRequest_MetadataEntry = {
  encode(message: DeleteRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<DeleteRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<DeleteRequest_MetadataEntry | DeleteRequest_MetadataEntry[]>
      | Iterable<DeleteRequest_MetadataEntry | DeleteRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [DeleteRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [DeleteRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, DeleteRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<DeleteRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [DeleteRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [DeleteRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): DeleteRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeleteRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRequest_MetadataEntry>, I>>(base?: I): DeleteRequest_MetadataEntry {
    return DeleteRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRequest_MetadataEntry>, I>>(object: I): DeleteRequest_MetadataEntry {
    const message = createBaseDeleteRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return {};
}

export const DeleteResponse = {
  encode(_: DeleteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<DeleteResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<DeleteResponse | DeleteResponse[]> | Iterable<DeleteResponse | DeleteResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [DeleteResponse.encode(p).finish()];
        }
      } else {
        yield* [DeleteResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, DeleteResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<DeleteResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [DeleteResponse.decode(p)];
        }
      } else {
        yield* [DeleteResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): DeleteResponse {
    return {};
  },

  toJSON(_: DeleteResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(_: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    return message;
  },
};

function createBaseSetRequest(): SetRequest {
  return { key: "", value: new Uint8Array(0), etag: undefined, metadata: {}, options: undefined, contentType: "" };
}

export const SetRequest = {
  encode(message: SetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    if (message.etag !== undefined) {
      Etag.encode(message.etag, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SetRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.options !== undefined) {
      StateOptions.encode(message.options, writer.uint32(42).fork()).ldelim();
    }
    if (message.contentType !== "") {
      writer.uint32(50).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = Etag.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = SetRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.options = StateOptions.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SetRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<SetRequest | SetRequest[]> | Iterable<SetRequest | SetRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SetRequest.encode(p).finish()];
        }
      } else {
        yield* [SetRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SetRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SetRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SetRequest.decode(p)];
        }
      } else {
        yield* [SetRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SetRequest {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      etag: isSet(object.etag) ? Etag.fromJSON(object.etag) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      options: isSet(object.options) ? StateOptions.fromJSON(object.options) : undefined,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: SetRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.etag !== undefined) {
      obj.etag = Etag.toJSON(message.etag);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.options !== undefined) {
      obj.options = StateOptions.toJSON(message.options);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetRequest>, I>>(base?: I): SetRequest {
    return SetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetRequest>, I>>(object: I): SetRequest {
    const message = createBaseSetRequest();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    message.etag = (object.etag !== undefined && object.etag !== null) ? Etag.fromPartial(object.etag) : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.options = (object.options !== undefined && object.options !== null)
      ? StateOptions.fromPartial(object.options)
      : undefined;
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseSetRequest_MetadataEntry(): SetRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const SetRequest_MetadataEntry = {
  encode(message: SetRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SetRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<SetRequest_MetadataEntry | SetRequest_MetadataEntry[]>
      | Iterable<SetRequest_MetadataEntry | SetRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SetRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [SetRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SetRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SetRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SetRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [SetRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): SetRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SetRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetRequest_MetadataEntry>, I>>(base?: I): SetRequest_MetadataEntry {
    return SetRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetRequest_MetadataEntry>, I>>(object: I): SetRequest_MetadataEntry {
    const message = createBaseSetRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetResponse(): SetResponse {
  return {};
}

export const SetResponse = {
  encode(_: SetResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<SetResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<SetResponse | SetResponse[]> | Iterable<SetResponse | SetResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SetResponse.encode(p).finish()];
        }
      } else {
        yield* [SetResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, SetResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<SetResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [SetResponse.decode(p)];
        }
      } else {
        yield* [SetResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): SetResponse {
    return {};
  },

  toJSON(_: SetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SetResponse>, I>>(base?: I): SetResponse {
    return SetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetResponse>, I>>(_: I): SetResponse {
    const message = createBaseSetResponse();
    return message;
  },
};

function createBaseBulkDeleteRequestOptions(): BulkDeleteRequestOptions {
  return { parallelism: Long.ZERO };
}

export const BulkDeleteRequestOptions = {
  encode(message: BulkDeleteRequestOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.parallelism.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.parallelism);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkDeleteRequestOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkDeleteRequestOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.parallelism = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkDeleteRequestOptions, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkDeleteRequestOptions | BulkDeleteRequestOptions[]>
      | Iterable<BulkDeleteRequestOptions | BulkDeleteRequestOptions[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkDeleteRequestOptions.encode(p).finish()];
        }
      } else {
        yield* [BulkDeleteRequestOptions.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkDeleteRequestOptions>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkDeleteRequestOptions> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkDeleteRequestOptions.decode(p)];
        }
      } else {
        yield* [BulkDeleteRequestOptions.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkDeleteRequestOptions {
    return { parallelism: isSet(object.parallelism) ? Long.fromValue(object.parallelism) : Long.ZERO };
  },

  toJSON(message: BulkDeleteRequestOptions): unknown {
    const obj: any = {};
    if (!message.parallelism.equals(Long.ZERO)) {
      obj.parallelism = (message.parallelism || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkDeleteRequestOptions>, I>>(base?: I): BulkDeleteRequestOptions {
    return BulkDeleteRequestOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkDeleteRequestOptions>, I>>(object: I): BulkDeleteRequestOptions {
    const message = createBaseBulkDeleteRequestOptions();
    message.parallelism = (object.parallelism !== undefined && object.parallelism !== null)
      ? Long.fromValue(object.parallelism)
      : Long.ZERO;
    return message;
  },
};

function createBaseBulkDeleteRequest(): BulkDeleteRequest {
  return { items: [], options: undefined };
}

export const BulkDeleteRequest = {
  encode(message: BulkDeleteRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      DeleteRequest.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.options !== undefined) {
      BulkDeleteRequestOptions.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkDeleteRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(DeleteRequest.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = BulkDeleteRequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkDeleteRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<BulkDeleteRequest | BulkDeleteRequest[]> | Iterable<BulkDeleteRequest | BulkDeleteRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkDeleteRequest.encode(p).finish()];
        }
      } else {
        yield* [BulkDeleteRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkDeleteRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkDeleteRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkDeleteRequest.decode(p)];
        }
      } else {
        yield* [BulkDeleteRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkDeleteRequest {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => DeleteRequest.fromJSON(e)) : [],
      options: isSet(object.options) ? BulkDeleteRequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: BulkDeleteRequest): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => DeleteRequest.toJSON(e));
    }
    if (message.options !== undefined) {
      obj.options = BulkDeleteRequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkDeleteRequest>, I>>(base?: I): BulkDeleteRequest {
    return BulkDeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkDeleteRequest>, I>>(object: I): BulkDeleteRequest {
    const message = createBaseBulkDeleteRequest();
    message.items = object.items?.map((e) => DeleteRequest.fromPartial(e)) || [];
    message.options = (object.options !== undefined && object.options !== null)
      ? BulkDeleteRequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseBulkDeleteResponse(): BulkDeleteResponse {
  return {};
}

export const BulkDeleteResponse = {
  encode(_: BulkDeleteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkDeleteResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkDeleteResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkDeleteResponse | BulkDeleteResponse[]>
      | Iterable<BulkDeleteResponse | BulkDeleteResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkDeleteResponse.encode(p).finish()];
        }
      } else {
        yield* [BulkDeleteResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkDeleteResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkDeleteResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkDeleteResponse.decode(p)];
        }
      } else {
        yield* [BulkDeleteResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): BulkDeleteResponse {
    return {};
  },

  toJSON(_: BulkDeleteResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkDeleteResponse>, I>>(base?: I): BulkDeleteResponse {
    return BulkDeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkDeleteResponse>, I>>(_: I): BulkDeleteResponse {
    const message = createBaseBulkDeleteResponse();
    return message;
  },
};

function createBaseBulkGetRequestOptions(): BulkGetRequestOptions {
  return { parallelism: Long.ZERO };
}

export const BulkGetRequestOptions = {
  encode(message: BulkGetRequestOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.parallelism.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.parallelism);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkGetRequestOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkGetRequestOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.parallelism = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkGetRequestOptions, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkGetRequestOptions | BulkGetRequestOptions[]>
      | Iterable<BulkGetRequestOptions | BulkGetRequestOptions[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetRequestOptions.encode(p).finish()];
        }
      } else {
        yield* [BulkGetRequestOptions.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkGetRequestOptions>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkGetRequestOptions> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetRequestOptions.decode(p)];
        }
      } else {
        yield* [BulkGetRequestOptions.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkGetRequestOptions {
    return { parallelism: isSet(object.parallelism) ? Long.fromValue(object.parallelism) : Long.ZERO };
  },

  toJSON(message: BulkGetRequestOptions): unknown {
    const obj: any = {};
    if (!message.parallelism.equals(Long.ZERO)) {
      obj.parallelism = (message.parallelism || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkGetRequestOptions>, I>>(base?: I): BulkGetRequestOptions {
    return BulkGetRequestOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkGetRequestOptions>, I>>(object: I): BulkGetRequestOptions {
    const message = createBaseBulkGetRequestOptions();
    message.parallelism = (object.parallelism !== undefined && object.parallelism !== null)
      ? Long.fromValue(object.parallelism)
      : Long.ZERO;
    return message;
  },
};

function createBaseBulkGetRequest(): BulkGetRequest {
  return { items: [], options: undefined };
}

export const BulkGetRequest = {
  encode(message: BulkGetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      GetRequest.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.options !== undefined) {
      BulkGetRequestOptions.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkGetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(GetRequest.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = BulkGetRequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkGetRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<BulkGetRequest | BulkGetRequest[]> | Iterable<BulkGetRequest | BulkGetRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetRequest.encode(p).finish()];
        }
      } else {
        yield* [BulkGetRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkGetRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkGetRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetRequest.decode(p)];
        }
      } else {
        yield* [BulkGetRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkGetRequest {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => GetRequest.fromJSON(e)) : [],
      options: isSet(object.options) ? BulkGetRequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: BulkGetRequest): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => GetRequest.toJSON(e));
    }
    if (message.options !== undefined) {
      obj.options = BulkGetRequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkGetRequest>, I>>(base?: I): BulkGetRequest {
    return BulkGetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkGetRequest>, I>>(object: I): BulkGetRequest {
    const message = createBaseBulkGetRequest();
    message.items = object.items?.map((e) => GetRequest.fromPartial(e)) || [];
    message.options = (object.options !== undefined && object.options !== null)
      ? BulkGetRequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseBulkStateItem(): BulkStateItem {
  return { key: "", data: new Uint8Array(0), etag: undefined, error: "", metadata: {}, contentType: "" };
}

export const BulkStateItem = {
  encode(message: BulkStateItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.etag !== undefined) {
      Etag.encode(message.etag, writer.uint32(26).fork()).ldelim();
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      BulkStateItem_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    if (message.contentType !== "") {
      writer.uint32(50).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkStateItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkStateItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = Etag.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = BulkStateItem_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkStateItem, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<BulkStateItem | BulkStateItem[]> | Iterable<BulkStateItem | BulkStateItem[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkStateItem.encode(p).finish()];
        }
      } else {
        yield* [BulkStateItem.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkStateItem>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkStateItem> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkStateItem.decode(p)];
        }
      } else {
        yield* [BulkStateItem.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkStateItem {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      etag: isSet(object.etag) ? Etag.fromJSON(object.etag) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: BulkStateItem): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.etag !== undefined) {
      obj.etag = Etag.toJSON(message.etag);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkStateItem>, I>>(base?: I): BulkStateItem {
    return BulkStateItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkStateItem>, I>>(object: I): BulkStateItem {
    const message = createBaseBulkStateItem();
    message.key = object.key ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.etag = (object.etag !== undefined && object.etag !== null) ? Etag.fromPartial(object.etag) : undefined;
    message.error = object.error ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseBulkStateItem_MetadataEntry(): BulkStateItem_MetadataEntry {
  return { key: "", value: "" };
}

export const BulkStateItem_MetadataEntry = {
  encode(message: BulkStateItem_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkStateItem_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkStateItem_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkStateItem_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkStateItem_MetadataEntry | BulkStateItem_MetadataEntry[]>
      | Iterable<BulkStateItem_MetadataEntry | BulkStateItem_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkStateItem_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [BulkStateItem_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkStateItem_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkStateItem_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkStateItem_MetadataEntry.decode(p)];
        }
      } else {
        yield* [BulkStateItem_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkStateItem_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BulkStateItem_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkStateItem_MetadataEntry>, I>>(base?: I): BulkStateItem_MetadataEntry {
    return BulkStateItem_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkStateItem_MetadataEntry>, I>>(object: I): BulkStateItem_MetadataEntry {
    const message = createBaseBulkStateItem_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBulkGetResponse(): BulkGetResponse {
  return { items: [] };
}

export const BulkGetResponse = {
  encode(message: BulkGetResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      BulkStateItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkGetResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(BulkStateItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkGetResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<BulkGetResponse | BulkGetResponse[]> | Iterable<BulkGetResponse | BulkGetResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetResponse.encode(p).finish()];
        }
      } else {
        yield* [BulkGetResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkGetResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkGetResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkGetResponse.decode(p)];
        }
      } else {
        yield* [BulkGetResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkGetResponse {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => BulkStateItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: BulkGetResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => BulkStateItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkGetResponse>, I>>(base?: I): BulkGetResponse {
    return BulkGetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkGetResponse>, I>>(object: I): BulkGetResponse {
    const message = createBaseBulkGetResponse();
    message.items = object.items?.map((e) => BulkStateItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBulkSetRequestOptions(): BulkSetRequestOptions {
  return { parallelism: Long.ZERO };
}

export const BulkSetRequestOptions = {
  encode(message: BulkSetRequestOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.parallelism.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.parallelism);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkSetRequestOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkSetRequestOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.parallelism = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkSetRequestOptions, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkSetRequestOptions | BulkSetRequestOptions[]>
      | Iterable<BulkSetRequestOptions | BulkSetRequestOptions[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkSetRequestOptions.encode(p).finish()];
        }
      } else {
        yield* [BulkSetRequestOptions.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkSetRequestOptions>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkSetRequestOptions> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkSetRequestOptions.decode(p)];
        }
      } else {
        yield* [BulkSetRequestOptions.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkSetRequestOptions {
    return { parallelism: isSet(object.parallelism) ? Long.fromValue(object.parallelism) : Long.ZERO };
  },

  toJSON(message: BulkSetRequestOptions): unknown {
    const obj: any = {};
    if (!message.parallelism.equals(Long.ZERO)) {
      obj.parallelism = (message.parallelism || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkSetRequestOptions>, I>>(base?: I): BulkSetRequestOptions {
    return BulkSetRequestOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkSetRequestOptions>, I>>(object: I): BulkSetRequestOptions {
    const message = createBaseBulkSetRequestOptions();
    message.parallelism = (object.parallelism !== undefined && object.parallelism !== null)
      ? Long.fromValue(object.parallelism)
      : Long.ZERO;
    return message;
  },
};

function createBaseBulkSetRequest(): BulkSetRequest {
  return { items: [], options: undefined };
}

export const BulkSetRequest = {
  encode(message: BulkSetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      SetRequest.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.options !== undefined) {
      BulkSetRequestOptions.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkSetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(SetRequest.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = BulkSetRequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkSetRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<BulkSetRequest | BulkSetRequest[]> | Iterable<BulkSetRequest | BulkSetRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkSetRequest.encode(p).finish()];
        }
      } else {
        yield* [BulkSetRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkSetRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkSetRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkSetRequest.decode(p)];
        }
      } else {
        yield* [BulkSetRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkSetRequest {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => SetRequest.fromJSON(e)) : [],
      options: isSet(object.options) ? BulkSetRequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: BulkSetRequest): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => SetRequest.toJSON(e));
    }
    if (message.options !== undefined) {
      obj.options = BulkSetRequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkSetRequest>, I>>(base?: I): BulkSetRequest {
    return BulkSetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkSetRequest>, I>>(object: I): BulkSetRequest {
    const message = createBaseBulkSetRequest();
    message.items = object.items?.map((e) => SetRequest.fromPartial(e)) || [];
    message.options = (object.options !== undefined && object.options !== null)
      ? BulkSetRequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseBulkSetResponse(): BulkSetResponse {
  return {};
}

export const BulkSetResponse = {
  encode(_: BulkSetResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkSetResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkSetResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<BulkSetResponse | BulkSetResponse[]> | Iterable<BulkSetResponse | BulkSetResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkSetResponse.encode(p).finish()];
        }
      } else {
        yield* [BulkSetResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkSetResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkSetResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkSetResponse.decode(p)];
        }
      } else {
        yield* [BulkSetResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): BulkSetResponse {
    return {};
  },

  toJSON(_: BulkSetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkSetResponse>, I>>(base?: I): BulkSetResponse {
    return BulkSetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkSetResponse>, I>>(_: I): BulkSetResponse {
    const message = createBaseBulkSetResponse();
    return message;
  },
};

/**
 * QueriableStateStore service provides a gRPC interface for querier state store
 * components. It was designed to embed query features to the StateStore Service
 * as a complementary service.
 */
export type QueriableStateStoreService = typeof QueriableStateStoreService;
export const QueriableStateStoreService = {
  /** Query performs a query request on the statestore. */
  query: {
    path: "/dapr.proto.components.v1.QueriableStateStore/Query",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRequest) => Buffer.from(QueryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryRequest.decode(value),
    responseSerialize: (value: QueryResponse) => Buffer.from(QueryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryResponse.decode(value),
  },
} as const;

export interface QueriableStateStoreServer extends UntypedServiceImplementation {
  /** Query performs a query request on the statestore. */
  query: handleUnaryCall<QueryRequest, QueryResponse>;
}

export interface QueriableStateStoreClient extends Client {
  /** Query performs a query request on the statestore. */
  query(
    request: QueryRequest,
    callback: (error: ServiceError | null, response: QueryResponse) => void,
  ): ClientUnaryCall;
  query(
    request: QueryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryResponse) => void,
  ): ClientUnaryCall;
  query(
    request: QueryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryResponse) => void,
  ): ClientUnaryCall;
}

export const QueriableStateStoreClient = makeGenericClientConstructor(
  QueriableStateStoreService,
  "dapr.proto.components.v1.QueriableStateStore",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): QueriableStateStoreClient;
  service: typeof QueriableStateStoreService;
  serviceName: string;
};

/**
 * TransactionalStateStore service provides a gRPC interface for transactional
 * state store components. It was designed to embed transactional features to
 * the StateStore Service as a complementary service.
 */
export type TransactionalStateStoreService = typeof TransactionalStateStoreService;
export const TransactionalStateStoreService = {
  /** Transact executes multiples operation in a transactional environment. */
  transact: {
    path: "/dapr.proto.components.v1.TransactionalStateStore/Transact",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransactionalStateRequest) =>
      Buffer.from(TransactionalStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransactionalStateRequest.decode(value),
    responseSerialize: (value: TransactionalStateResponse) =>
      Buffer.from(TransactionalStateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionalStateResponse.decode(value),
  },
} as const;

export interface TransactionalStateStoreServer extends UntypedServiceImplementation {
  /** Transact executes multiples operation in a transactional environment. */
  transact: handleUnaryCall<TransactionalStateRequest, TransactionalStateResponse>;
}

export interface TransactionalStateStoreClient extends Client {
  /** Transact executes multiples operation in a transactional environment. */
  transact(
    request: TransactionalStateRequest,
    callback: (error: ServiceError | null, response: TransactionalStateResponse) => void,
  ): ClientUnaryCall;
  transact(
    request: TransactionalStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionalStateResponse) => void,
  ): ClientUnaryCall;
  transact(
    request: TransactionalStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionalStateResponse) => void,
  ): ClientUnaryCall;
}

export const TransactionalStateStoreClient = makeGenericClientConstructor(
  TransactionalStateStoreService,
  "dapr.proto.components.v1.TransactionalStateStore",
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): TransactionalStateStoreClient;
  service: typeof TransactionalStateStoreService;
  serviceName: string;
};

/** StateStore service provides a gRPC interface for state store components. */
export type StateStoreService = typeof StateStoreService;
export const StateStoreService = {
  /** Initializes the state store component with the given metadata. */
  init: {
    path: "/dapr.proto.components.v1.StateStore/Init",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InitRequest) => Buffer.from(InitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InitRequest.decode(value),
    responseSerialize: (value: InitResponse) => Buffer.from(InitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InitResponse.decode(value),
  },
  /** Returns a list of implemented state store features. */
  features: {
    path: "/dapr.proto.components.v1.StateStore/Features",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FeaturesRequest) => Buffer.from(FeaturesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FeaturesRequest.decode(value),
    responseSerialize: (value: FeaturesResponse) => Buffer.from(FeaturesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FeaturesResponse.decode(value),
  },
  /** Deletes the specified key from the state store. */
  delete: {
    path: "/dapr.proto.components.v1.StateStore/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRequest) => Buffer.from(DeleteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteRequest.decode(value),
    responseSerialize: (value: DeleteResponse) => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteResponse.decode(value),
  },
  /** Get data from the given key. */
  get: {
    path: "/dapr.proto.components.v1.StateStore/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRequest) => Buffer.from(GetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetRequest.decode(value),
    responseSerialize: (value: GetResponse) => Buffer.from(GetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetResponse.decode(value),
  },
  /** Sets the value of the specified key. */
  set: {
    path: "/dapr.proto.components.v1.StateStore/Set",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetRequest) => Buffer.from(SetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SetRequest.decode(value),
    responseSerialize: (value: SetResponse) => Buffer.from(SetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SetResponse.decode(value),
  },
  /** Ping the state store. Used for liveness porpuses. */
  ping: {
    path: "/dapr.proto.components.v1.StateStore/Ping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PingRequest) => Buffer.from(PingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PingRequest.decode(value),
    responseSerialize: (value: PingResponse) => Buffer.from(PingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PingResponse.decode(value),
  },
  /** Deletes many keys at once. */
  bulkDelete: {
    path: "/dapr.proto.components.v1.StateStore/BulkDelete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BulkDeleteRequest) => Buffer.from(BulkDeleteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BulkDeleteRequest.decode(value),
    responseSerialize: (value: BulkDeleteResponse) => Buffer.from(BulkDeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BulkDeleteResponse.decode(value),
  },
  /** Retrieves many keys at once. */
  bulkGet: {
    path: "/dapr.proto.components.v1.StateStore/BulkGet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BulkGetRequest) => Buffer.from(BulkGetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BulkGetRequest.decode(value),
    responseSerialize: (value: BulkGetResponse) => Buffer.from(BulkGetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BulkGetResponse.decode(value),
  },
  /** Set the value of many keys at once. */
  bulkSet: {
    path: "/dapr.proto.components.v1.StateStore/BulkSet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BulkSetRequest) => Buffer.from(BulkSetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BulkSetRequest.decode(value),
    responseSerialize: (value: BulkSetResponse) => Buffer.from(BulkSetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BulkSetResponse.decode(value),
  },
} as const;

export interface StateStoreServer extends UntypedServiceImplementation {
  /** Initializes the state store component with the given metadata. */
  init: handleUnaryCall<InitRequest, InitResponse>;
  /** Returns a list of implemented state store features. */
  features: handleUnaryCall<FeaturesRequest, FeaturesResponse>;
  /** Deletes the specified key from the state store. */
  delete: handleUnaryCall<DeleteRequest, DeleteResponse>;
  /** Get data from the given key. */
  get: handleUnaryCall<GetRequest, GetResponse>;
  /** Sets the value of the specified key. */
  set: handleUnaryCall<SetRequest, SetResponse>;
  /** Ping the state store. Used for liveness porpuses. */
  ping: handleUnaryCall<PingRequest, PingResponse>;
  /** Deletes many keys at once. */
  bulkDelete: handleUnaryCall<BulkDeleteRequest, BulkDeleteResponse>;
  /** Retrieves many keys at once. */
  bulkGet: handleUnaryCall<BulkGetRequest, BulkGetResponse>;
  /** Set the value of many keys at once. */
  bulkSet: handleUnaryCall<BulkSetRequest, BulkSetResponse>;
}

export interface StateStoreClient extends Client {
  /** Initializes the state store component with the given metadata. */
  init(request: InitRequest, callback: (error: ServiceError | null, response: InitResponse) => void): ClientUnaryCall;
  init(
    request: InitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InitResponse) => void,
  ): ClientUnaryCall;
  init(
    request: InitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InitResponse) => void,
  ): ClientUnaryCall;
  /** Returns a list of implemented state store features. */
  features(
    request: FeaturesRequest,
    callback: (error: ServiceError | null, response: FeaturesResponse) => void,
  ): ClientUnaryCall;
  features(
    request: FeaturesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: FeaturesResponse) => void,
  ): ClientUnaryCall;
  features(
    request: FeaturesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: FeaturesResponse) => void,
  ): ClientUnaryCall;
  /** Deletes the specified key from the state store. */
  delete(
    request: DeleteRequest,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  /** Get data from the given key. */
  get(request: GetRequest, callback: (error: ServiceError | null, response: GetResponse) => void): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  /** Sets the value of the specified key. */
  set(request: SetRequest, callback: (error: ServiceError | null, response: SetResponse) => void): ClientUnaryCall;
  set(
    request: SetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SetResponse) => void,
  ): ClientUnaryCall;
  set(
    request: SetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SetResponse) => void,
  ): ClientUnaryCall;
  /** Ping the state store. Used for liveness porpuses. */
  ping(request: PingRequest, callback: (error: ServiceError | null, response: PingResponse) => void): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
  /** Deletes many keys at once. */
  bulkDelete(
    request: BulkDeleteRequest,
    callback: (error: ServiceError | null, response: BulkDeleteResponse) => void,
  ): ClientUnaryCall;
  bulkDelete(
    request: BulkDeleteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BulkDeleteResponse) => void,
  ): ClientUnaryCall;
  bulkDelete(
    request: BulkDeleteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BulkDeleteResponse) => void,
  ): ClientUnaryCall;
  /** Retrieves many keys at once. */
  bulkGet(
    request: BulkGetRequest,
    callback: (error: ServiceError | null, response: BulkGetResponse) => void,
  ): ClientUnaryCall;
  bulkGet(
    request: BulkGetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BulkGetResponse) => void,
  ): ClientUnaryCall;
  bulkGet(
    request: BulkGetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BulkGetResponse) => void,
  ): ClientUnaryCall;
  /** Set the value of many keys at once. */
  bulkSet(
    request: BulkSetRequest,
    callback: (error: ServiceError | null, response: BulkSetResponse) => void,
  ): ClientUnaryCall;
  bulkSet(
    request: BulkSetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BulkSetResponse) => void,
  ): ClientUnaryCall;
  bulkSet(
    request: BulkSetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BulkSetResponse) => void,
  ): ClientUnaryCall;
}

export const StateStoreClient = makeGenericClientConstructor(
  StateStoreService,
  "dapr.proto.components.v1.StateStore",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): StateStoreClient;
  service: typeof StateStoreService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
