// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.19.1
// source: dapr/proto/components/v1/bindings.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { MetadataRequest, PingRequest, PingResponse } from "./common";

export const protobufPackage = "dapr.proto.components.v1";

/** reserved for future-proof extensibility */
export interface ListOperationsRequest {
}

export interface ListOperationsResponse {
  /** the list of all supported component operations. */
  operations: string[];
}

/**
 * InputBindingInitRequest is the request for initializing the input binding
 * component.
 */
export interface InputBindingInitRequest {
  /** The metadata request. */
  metadata: MetadataRequest | undefined;
}

/** reserved for future-proof extensibility */
export interface InputBindingInitResponse {
}

/**
 * OutputBindingInitRequest is the request for initializing the output binding
 * component.
 */
export interface OutputBindingInitRequest {
  /** The metadata request. */
  metadata: MetadataRequest | undefined;
}

/** reserved for future-proof extensibility */
export interface OutputBindingInitResponse {
}

/** Used for describing errors when ack'ing messages. */
export interface AckResponseError {
  message: string;
}

export interface ReadRequest {
  /** The handle response. */
  responseData: Uint8Array;
  /** The unique message ID. */
  messageId: string;
  /**
   * Optional, should not be fulfilled when the message was successfully
   * handled.
   */
  responseError: AckResponseError | undefined;
}

export interface ReadResponse {
  /** The Read binding Data. */
  data: Uint8Array;
  /** The message metadata */
  metadata: { [key: string]: string };
  /** The message content type. */
  contentType: string;
  /** The {transient} message ID used for ACK-ing it later. */
  messageId: string;
}

export interface ReadResponse_MetadataEntry {
  key: string;
  value: string;
}

/** Used for invoking systems with optional payload. */
export interface InvokeRequest {
  /** The invoke payload. */
  data: Uint8Array;
  /** The invoke metadata. */
  metadata: { [key: string]: string };
  /** The system supported operation. */
  operation: string;
}

export interface InvokeRequest_MetadataEntry {
  key: string;
  value: string;
}

/** Response from the invoked system. */
export interface InvokeResponse {
  /** The response payload. */
  data: Uint8Array;
  /** The response metadata. */
  metadata: { [key: string]: string };
  /** The response content-type. */
  contentType: string;
}

export interface InvokeResponse_MetadataEntry {
  key: string;
  value: string;
}

function createBaseListOperationsRequest(): ListOperationsRequest {
  return {};
}

export const ListOperationsRequest = {
  encode(_: ListOperationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListOperationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListOperationsRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListOperationsRequest | ListOperationsRequest[]>
      | Iterable<ListOperationsRequest | ListOperationsRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListOperationsRequest.encode(p).finish()];
        }
      } else {
        yield* [ListOperationsRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListOperationsRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListOperationsRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListOperationsRequest.decode(p)];
        }
      } else {
        yield* [ListOperationsRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): ListOperationsRequest {
    return {};
  },

  toJSON(_: ListOperationsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOperationsRequest>, I>>(base?: I): ListOperationsRequest {
    return ListOperationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOperationsRequest>, I>>(_: I): ListOperationsRequest {
    const message = createBaseListOperationsRequest();
    return message;
  },
};

function createBaseListOperationsResponse(): ListOperationsResponse {
  return { operations: [] };
}

export const ListOperationsResponse = {
  encode(message: ListOperationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.operations) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListOperationsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListOperationsResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListOperationsResponse | ListOperationsResponse[]>
      | Iterable<ListOperationsResponse | ListOperationsResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListOperationsResponse.encode(p).finish()];
        }
      } else {
        yield* [ListOperationsResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListOperationsResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListOperationsResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListOperationsResponse.decode(p)];
        }
      } else {
        yield* [ListOperationsResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListOperationsResponse {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListOperationsResponse): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOperationsResponse>, I>>(base?: I): ListOperationsResponse {
    return ListOperationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOperationsResponse>, I>>(object: I): ListOperationsResponse {
    const message = createBaseListOperationsResponse();
    message.operations = object.operations?.map((e) => e) || [];
    return message;
  },
};

function createBaseInputBindingInitRequest(): InputBindingInitRequest {
  return { metadata: undefined };
}

export const InputBindingInitRequest = {
  encode(message: InputBindingInitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      MetadataRequest.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InputBindingInitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputBindingInitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = MetadataRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InputBindingInitRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InputBindingInitRequest | InputBindingInitRequest[]>
      | Iterable<InputBindingInitRequest | InputBindingInitRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InputBindingInitRequest.encode(p).finish()];
        }
      } else {
        yield* [InputBindingInitRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InputBindingInitRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InputBindingInitRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InputBindingInitRequest.decode(p)];
        }
      } else {
        yield* [InputBindingInitRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InputBindingInitRequest {
    return { metadata: isSet(object.metadata) ? MetadataRequest.fromJSON(object.metadata) : undefined };
  },

  toJSON(message: InputBindingInitRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = MetadataRequest.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputBindingInitRequest>, I>>(base?: I): InputBindingInitRequest {
    return InputBindingInitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputBindingInitRequest>, I>>(object: I): InputBindingInitRequest {
    const message = createBaseInputBindingInitRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetadataRequest.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseInputBindingInitResponse(): InputBindingInitResponse {
  return {};
}

export const InputBindingInitResponse = {
  encode(_: InputBindingInitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InputBindingInitResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputBindingInitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InputBindingInitResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InputBindingInitResponse | InputBindingInitResponse[]>
      | Iterable<InputBindingInitResponse | InputBindingInitResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InputBindingInitResponse.encode(p).finish()];
        }
      } else {
        yield* [InputBindingInitResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InputBindingInitResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InputBindingInitResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InputBindingInitResponse.decode(p)];
        }
      } else {
        yield* [InputBindingInitResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): InputBindingInitResponse {
    return {};
  },

  toJSON(_: InputBindingInitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<InputBindingInitResponse>, I>>(base?: I): InputBindingInitResponse {
    return InputBindingInitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputBindingInitResponse>, I>>(_: I): InputBindingInitResponse {
    const message = createBaseInputBindingInitResponse();
    return message;
  },
};

function createBaseOutputBindingInitRequest(): OutputBindingInitRequest {
  return { metadata: undefined };
}

export const OutputBindingInitRequest = {
  encode(message: OutputBindingInitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      MetadataRequest.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutputBindingInitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputBindingInitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = MetadataRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<OutputBindingInitRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<OutputBindingInitRequest | OutputBindingInitRequest[]>
      | Iterable<OutputBindingInitRequest | OutputBindingInitRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [OutputBindingInitRequest.encode(p).finish()];
        }
      } else {
        yield* [OutputBindingInitRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, OutputBindingInitRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<OutputBindingInitRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [OutputBindingInitRequest.decode(p)];
        }
      } else {
        yield* [OutputBindingInitRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): OutputBindingInitRequest {
    return { metadata: isSet(object.metadata) ? MetadataRequest.fromJSON(object.metadata) : undefined };
  },

  toJSON(message: OutputBindingInitRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = MetadataRequest.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputBindingInitRequest>, I>>(base?: I): OutputBindingInitRequest {
    return OutputBindingInitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputBindingInitRequest>, I>>(object: I): OutputBindingInitRequest {
    const message = createBaseOutputBindingInitRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetadataRequest.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseOutputBindingInitResponse(): OutputBindingInitResponse {
  return {};
}

export const OutputBindingInitResponse = {
  encode(_: OutputBindingInitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutputBindingInitResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputBindingInitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<OutputBindingInitResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<OutputBindingInitResponse | OutputBindingInitResponse[]>
      | Iterable<OutputBindingInitResponse | OutputBindingInitResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [OutputBindingInitResponse.encode(p).finish()];
        }
      } else {
        yield* [OutputBindingInitResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, OutputBindingInitResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<OutputBindingInitResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [OutputBindingInitResponse.decode(p)];
        }
      } else {
        yield* [OutputBindingInitResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): OutputBindingInitResponse {
    return {};
  },

  toJSON(_: OutputBindingInitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputBindingInitResponse>, I>>(base?: I): OutputBindingInitResponse {
    return OutputBindingInitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputBindingInitResponse>, I>>(_: I): OutputBindingInitResponse {
    const message = createBaseOutputBindingInitResponse();
    return message;
  },
};

function createBaseAckResponseError(): AckResponseError {
  return { message: "" };
}

export const AckResponseError = {
  encode(message: AckResponseError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AckResponseError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAckResponseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<AckResponseError, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<AckResponseError | AckResponseError[]> | Iterable<AckResponseError | AckResponseError[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [AckResponseError.encode(p).finish()];
        }
      } else {
        yield* [AckResponseError.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, AckResponseError>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<AckResponseError> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [AckResponseError.decode(p)];
        }
      } else {
        yield* [AckResponseError.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): AckResponseError {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: AckResponseError): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AckResponseError>, I>>(base?: I): AckResponseError {
    return AckResponseError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AckResponseError>, I>>(object: I): AckResponseError {
    const message = createBaseAckResponseError();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseReadRequest(): ReadRequest {
  return { responseData: new Uint8Array(0), messageId: "", responseError: undefined };
}

export const ReadRequest = {
  encode(message: ReadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.responseData.length !== 0) {
      writer.uint32(10).bytes(message.responseData);
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.responseError !== undefined) {
      AckResponseError.encode(message.responseError, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.responseData = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.responseError = AckResponseError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ReadRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<ReadRequest | ReadRequest[]> | Iterable<ReadRequest | ReadRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ReadRequest.encode(p).finish()];
        }
      } else {
        yield* [ReadRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ReadRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ReadRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ReadRequest.decode(p)];
        }
      } else {
        yield* [ReadRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ReadRequest {
    return {
      responseData: isSet(object.responseData) ? bytesFromBase64(object.responseData) : new Uint8Array(0),
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      responseError: isSet(object.responseError) ? AckResponseError.fromJSON(object.responseError) : undefined,
    };
  },

  toJSON(message: ReadRequest): unknown {
    const obj: any = {};
    if (message.responseData.length !== 0) {
      obj.responseData = base64FromBytes(message.responseData);
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.responseError !== undefined) {
      obj.responseError = AckResponseError.toJSON(message.responseError);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadRequest>, I>>(base?: I): ReadRequest {
    return ReadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadRequest>, I>>(object: I): ReadRequest {
    const message = createBaseReadRequest();
    message.responseData = object.responseData ?? new Uint8Array(0);
    message.messageId = object.messageId ?? "";
    message.responseError = (object.responseError !== undefined && object.responseError !== null)
      ? AckResponseError.fromPartial(object.responseError)
      : undefined;
    return message;
  },
};

function createBaseReadResponse(): ReadResponse {
  return { data: new Uint8Array(0), metadata: {}, contentType: "", messageId: "" };
}

export const ReadResponse = {
  encode(message: ReadResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ReadResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (message.messageId !== "") {
      writer.uint32(34).string(message.messageId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = ReadResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.messageId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ReadResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<ReadResponse | ReadResponse[]> | Iterable<ReadResponse | ReadResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ReadResponse.encode(p).finish()];
        }
      } else {
        yield* [ReadResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ReadResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ReadResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ReadResponse.decode(p)];
        }
      } else {
        yield* [ReadResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ReadResponse {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
    };
  },

  toJSON(message: ReadResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadResponse>, I>>(base?: I): ReadResponse {
    return ReadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadResponse>, I>>(object: I): ReadResponse {
    const message = createBaseReadResponse();
    message.data = object.data ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.contentType = object.contentType ?? "";
    message.messageId = object.messageId ?? "";
    return message;
  },
};

function createBaseReadResponse_MetadataEntry(): ReadResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const ReadResponse_MetadataEntry = {
  encode(message: ReadResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ReadResponse_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ReadResponse_MetadataEntry | ReadResponse_MetadataEntry[]>
      | Iterable<ReadResponse_MetadataEntry | ReadResponse_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ReadResponse_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [ReadResponse_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ReadResponse_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ReadResponse_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ReadResponse_MetadataEntry.decode(p)];
        }
      } else {
        yield* [ReadResponse_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ReadResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ReadResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadResponse_MetadataEntry>, I>>(base?: I): ReadResponse_MetadataEntry {
    return ReadResponse_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadResponse_MetadataEntry>, I>>(object: I): ReadResponse_MetadataEntry {
    const message = createBaseReadResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInvokeRequest(): InvokeRequest {
  return { data: new Uint8Array(0), metadata: {}, operation: "" };
}

export const InvokeRequest = {
  encode(message: InvokeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      InvokeRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.operation !== "") {
      writer.uint32(26).string(message.operation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = InvokeRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InvokeRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<InvokeRequest | InvokeRequest[]> | Iterable<InvokeRequest | InvokeRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeRequest.encode(p).finish()];
        }
      } else {
        yield* [InvokeRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InvokeRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InvokeRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeRequest.decode(p)];
        }
      } else {
        yield* [InvokeRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InvokeRequest {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
    };
  },

  toJSON(message: InvokeRequest): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeRequest>, I>>(base?: I): InvokeRequest {
    return InvokeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeRequest>, I>>(object: I): InvokeRequest {
    const message = createBaseInvokeRequest();
    message.data = object.data ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.operation = object.operation ?? "";
    return message;
  },
};

function createBaseInvokeRequest_MetadataEntry(): InvokeRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const InvokeRequest_MetadataEntry = {
  encode(message: InvokeRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InvokeRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InvokeRequest_MetadataEntry | InvokeRequest_MetadataEntry[]>
      | Iterable<InvokeRequest_MetadataEntry | InvokeRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [InvokeRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InvokeRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InvokeRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [InvokeRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InvokeRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: InvokeRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeRequest_MetadataEntry>, I>>(base?: I): InvokeRequest_MetadataEntry {
    return InvokeRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeRequest_MetadataEntry>, I>>(object: I): InvokeRequest_MetadataEntry {
    const message = createBaseInvokeRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInvokeResponse(): InvokeResponse {
  return { data: new Uint8Array(0), metadata: {}, contentType: "" };
}

export const InvokeResponse = {
  encode(message: InvokeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      InvokeResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = InvokeResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InvokeResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<InvokeResponse | InvokeResponse[]> | Iterable<InvokeResponse | InvokeResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeResponse.encode(p).finish()];
        }
      } else {
        yield* [InvokeResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InvokeResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InvokeResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeResponse.decode(p)];
        }
      } else {
        yield* [InvokeResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InvokeResponse {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: InvokeResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeResponse>, I>>(base?: I): InvokeResponse {
    return InvokeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeResponse>, I>>(object: I): InvokeResponse {
    const message = createBaseInvokeResponse();
    message.data = object.data ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseInvokeResponse_MetadataEntry(): InvokeResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const InvokeResponse_MetadataEntry = {
  encode(message: InvokeResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InvokeResponse_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InvokeResponse_MetadataEntry | InvokeResponse_MetadataEntry[]>
      | Iterable<InvokeResponse_MetadataEntry | InvokeResponse_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeResponse_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [InvokeResponse_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InvokeResponse_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InvokeResponse_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeResponse_MetadataEntry.decode(p)];
        }
      } else {
        yield* [InvokeResponse_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InvokeResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: InvokeResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeResponse_MetadataEntry>, I>>(base?: I): InvokeResponse_MetadataEntry {
    return InvokeResponse_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeResponse_MetadataEntry>, I>>(object: I): InvokeResponse_MetadataEntry {
    const message = createBaseInvokeResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

/** Interface for input bindings */
export type InputBindingService = typeof InputBindingService;
export const InputBindingService = {
  /** Initializes the inputbinding component component with the given metadata. */
  init: {
    path: "/dapr.proto.components.v1.InputBinding/Init",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InputBindingInitRequest) => Buffer.from(InputBindingInitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InputBindingInitRequest.decode(value),
    responseSerialize: (value: InputBindingInitResponse) =>
      Buffer.from(InputBindingInitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InputBindingInitResponse.decode(value),
  },
  /**
   * Establishes a stream with the server, which sends messages down to the
   * client. The client streams acknowledgements back to the server. The server
   * will close the stream and return the status on any error. In case of closed
   * connection, the client should re-establish the stream.
   */
  read: {
    path: "/dapr.proto.components.v1.InputBinding/Read",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ReadRequest) => Buffer.from(ReadRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReadRequest.decode(value),
    responseSerialize: (value: ReadResponse) => Buffer.from(ReadResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ReadResponse.decode(value),
  },
  /** Ping the InputBinding. Used for liveness porpuses. */
  ping: {
    path: "/dapr.proto.components.v1.InputBinding/Ping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PingRequest) => Buffer.from(PingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PingRequest.decode(value),
    responseSerialize: (value: PingResponse) => Buffer.from(PingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PingResponse.decode(value),
  },
} as const;

export interface InputBindingServer extends UntypedServiceImplementation {
  /** Initializes the inputbinding component component with the given metadata. */
  init: handleUnaryCall<InputBindingInitRequest, InputBindingInitResponse>;
  /**
   * Establishes a stream with the server, which sends messages down to the
   * client. The client streams acknowledgements back to the server. The server
   * will close the stream and return the status on any error. In case of closed
   * connection, the client should re-establish the stream.
   */
  read: handleBidiStreamingCall<ReadRequest, ReadResponse>;
  /** Ping the InputBinding. Used for liveness porpuses. */
  ping: handleUnaryCall<PingRequest, PingResponse>;
}

export interface InputBindingClient extends Client {
  /** Initializes the inputbinding component component with the given metadata. */
  init(
    request: InputBindingInitRequest,
    callback: (error: ServiceError | null, response: InputBindingInitResponse) => void,
  ): ClientUnaryCall;
  init(
    request: InputBindingInitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InputBindingInitResponse) => void,
  ): ClientUnaryCall;
  init(
    request: InputBindingInitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InputBindingInitResponse) => void,
  ): ClientUnaryCall;
  /**
   * Establishes a stream with the server, which sends messages down to the
   * client. The client streams acknowledgements back to the server. The server
   * will close the stream and return the status on any error. In case of closed
   * connection, the client should re-establish the stream.
   */
  read(): ClientDuplexStream<ReadRequest, ReadResponse>;
  read(options: Partial<CallOptions>): ClientDuplexStream<ReadRequest, ReadResponse>;
  read(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<ReadRequest, ReadResponse>;
  /** Ping the InputBinding. Used for liveness porpuses. */
  ping(request: PingRequest, callback: (error: ServiceError | null, response: PingResponse) => void): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
}

export const InputBindingClient = makeGenericClientConstructor(
  InputBindingService,
  "dapr.proto.components.v1.InputBinding",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): InputBindingClient;
  service: typeof InputBindingService;
  serviceName: string;
};

export type OutputBindingService = typeof OutputBindingService;
export const OutputBindingService = {
  /** Initializes the outputbinding component component with the given metadata. */
  init: {
    path: "/dapr.proto.components.v1.OutputBinding/Init",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OutputBindingInitRequest) => Buffer.from(OutputBindingInitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OutputBindingInitRequest.decode(value),
    responseSerialize: (value: OutputBindingInitResponse) =>
      Buffer.from(OutputBindingInitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OutputBindingInitResponse.decode(value),
  },
  /** Invoke remote systems with optional payloads. */
  invoke: {
    path: "/dapr.proto.components.v1.OutputBinding/Invoke",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InvokeRequest) => Buffer.from(InvokeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InvokeRequest.decode(value),
    responseSerialize: (value: InvokeResponse) => Buffer.from(InvokeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InvokeResponse.decode(value),
  },
  /** ListOperations list system supported operations. */
  listOperations: {
    path: "/dapr.proto.components.v1.OutputBinding/ListOperations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListOperationsRequest) => Buffer.from(ListOperationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListOperationsRequest.decode(value),
    responseSerialize: (value: ListOperationsResponse) => Buffer.from(ListOperationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListOperationsResponse.decode(value),
  },
  /** Ping the OutputBinding. Used for liveness porpuses. */
  ping: {
    path: "/dapr.proto.components.v1.OutputBinding/Ping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PingRequest) => Buffer.from(PingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PingRequest.decode(value),
    responseSerialize: (value: PingResponse) => Buffer.from(PingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PingResponse.decode(value),
  },
} as const;

export interface OutputBindingServer extends UntypedServiceImplementation {
  /** Initializes the outputbinding component component with the given metadata. */
  init: handleUnaryCall<OutputBindingInitRequest, OutputBindingInitResponse>;
  /** Invoke remote systems with optional payloads. */
  invoke: handleUnaryCall<InvokeRequest, InvokeResponse>;
  /** ListOperations list system supported operations. */
  listOperations: handleUnaryCall<ListOperationsRequest, ListOperationsResponse>;
  /** Ping the OutputBinding. Used for liveness porpuses. */
  ping: handleUnaryCall<PingRequest, PingResponse>;
}

export interface OutputBindingClient extends Client {
  /** Initializes the outputbinding component component with the given metadata. */
  init(
    request: OutputBindingInitRequest,
    callback: (error: ServiceError | null, response: OutputBindingInitResponse) => void,
  ): ClientUnaryCall;
  init(
    request: OutputBindingInitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: OutputBindingInitResponse) => void,
  ): ClientUnaryCall;
  init(
    request: OutputBindingInitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: OutputBindingInitResponse) => void,
  ): ClientUnaryCall;
  /** Invoke remote systems with optional payloads. */
  invoke(
    request: InvokeRequest,
    callback: (error: ServiceError | null, response: InvokeResponse) => void,
  ): ClientUnaryCall;
  invoke(
    request: InvokeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InvokeResponse) => void,
  ): ClientUnaryCall;
  invoke(
    request: InvokeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InvokeResponse) => void,
  ): ClientUnaryCall;
  /** ListOperations list system supported operations. */
  listOperations(
    request: ListOperationsRequest,
    callback: (error: ServiceError | null, response: ListOperationsResponse) => void,
  ): ClientUnaryCall;
  listOperations(
    request: ListOperationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListOperationsResponse) => void,
  ): ClientUnaryCall;
  listOperations(
    request: ListOperationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListOperationsResponse) => void,
  ): ClientUnaryCall;
  /** Ping the OutputBinding. Used for liveness porpuses. */
  ping(request: PingRequest, callback: (error: ServiceError | null, response: PingResponse) => void): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
}

export const OutputBindingClient = makeGenericClientConstructor(
  OutputBindingService,
  "dapr.proto.components.v1.OutputBinding",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OutputBindingClient;
  service: typeof OutputBindingService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
