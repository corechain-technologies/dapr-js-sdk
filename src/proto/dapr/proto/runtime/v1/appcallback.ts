// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.19.1
// source: dapr/proto/runtime/v1/appcallback.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Empty } from "../../../../google/protobuf/empty";
import { Struct } from "../../../../google/protobuf/struct";
import { InvokeRequest, InvokeResponse, StateItem } from "../../common/v1/common";

export const protobufPackage = "dapr.proto.runtime.v1";

/**
 * TopicEventRequest message is compatible with CloudEvent spec v1.0
 * https://github.com/cloudevents/spec/blob/v1.0/spec.md
 */
export interface TopicEventRequest {
  /**
   * id identifies the event. Producers MUST ensure that source + id
   * is unique for each distinct event. If a duplicate event is re-sent
   * (e.g. due to a network error) it MAY have the same id.
   */
  id: string;
  /**
   * source identifies the context in which an event happened.
   * Often this will include information such as the type of the
   * event source, the organization publishing the event or the process
   * that produced the event. The exact syntax and semantics behind
   * the data encoded in the URI is defined by the event producer.
   */
  source: string;
  /** The type of event related to the originating occurrence. */
  type: string;
  /** The version of the CloudEvents specification. */
  specVersion: string;
  /** The content type of data value. */
  dataContentType: string;
  /** The content of the event. */
  data: Uint8Array;
  /** The pubsub topic which publisher sent to. */
  topic: string;
  /** The name of the pubsub the publisher sent to. */
  pubsubName: string;
  /**
   * The matching path from TopicSubscription/routes (if specified) for this event.
   * This value is used by OnTopicEvent to "switch" inside the handler.
   */
  path: string;
  /** The map of additional custom properties to be sent to the app. These are considered to be cloud event extensions. */
  extensions: { [key: string]: any } | undefined;
}

/** TopicEventResponse is response from app on published message */
export interface TopicEventResponse {
  /** The list of output bindings. */
  status: TopicEventResponse_TopicEventResponseStatus;
}

/** TopicEventResponseStatus allows apps to have finer control over handling of the message. */
export enum TopicEventResponse_TopicEventResponseStatus {
  /** SUCCESS - SUCCESS is the default behavior: message is acknowledged and not retried or logged. */
  SUCCESS = "SUCCESS",
  /** RETRY - RETRY status signals Dapr to retry the message as part of an expected scenario (no warning is logged). */
  RETRY = "RETRY",
  /** DROP - DROP status signals Dapr to drop the message as part of an unexpected scenario (warning is logged). */
  DROP = "DROP",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function topicEventResponse_TopicEventResponseStatusFromJSON(
  object: any,
): TopicEventResponse_TopicEventResponseStatus {
  switch (object) {
    case 0:
    case "SUCCESS":
      return TopicEventResponse_TopicEventResponseStatus.SUCCESS;
    case 1:
    case "RETRY":
      return TopicEventResponse_TopicEventResponseStatus.RETRY;
    case 2:
    case "DROP":
      return TopicEventResponse_TopicEventResponseStatus.DROP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TopicEventResponse_TopicEventResponseStatus.UNRECOGNIZED;
  }
}

export function topicEventResponse_TopicEventResponseStatusToJSON(
  object: TopicEventResponse_TopicEventResponseStatus,
): string {
  switch (object) {
    case TopicEventResponse_TopicEventResponseStatus.SUCCESS:
      return "SUCCESS";
    case TopicEventResponse_TopicEventResponseStatus.RETRY:
      return "RETRY";
    case TopicEventResponse_TopicEventResponseStatus.DROP:
      return "DROP";
    case TopicEventResponse_TopicEventResponseStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function topicEventResponse_TopicEventResponseStatusToNumber(
  object: TopicEventResponse_TopicEventResponseStatus,
): number {
  switch (object) {
    case TopicEventResponse_TopicEventResponseStatus.SUCCESS:
      return 0;
    case TopicEventResponse_TopicEventResponseStatus.RETRY:
      return 1;
    case TopicEventResponse_TopicEventResponseStatus.DROP:
      return 2;
    case TopicEventResponse_TopicEventResponseStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** TopicEventCERequest message is compatible with CloudEvent spec v1.0 */
export interface TopicEventCERequest {
  /** The unique identifier of this cloud event. */
  id: string;
  /** source identifies the context in which an event happened. */
  source: string;
  /** The type of event related to the originating occurrence. */
  type: string;
  /** The version of the CloudEvents specification. */
  specVersion: string;
  /** The content type of data value. */
  dataContentType: string;
  /** The content of the event. */
  data: Uint8Array;
  /** Custom attributes which includes cloud event extensions. */
  extensions: { [key: string]: any } | undefined;
}

/** TopicEventBulkRequestEntry represents a single message inside a bulk request */
export interface TopicEventBulkRequestEntry {
  /** Unique identifier for the message. */
  entryId: string;
  bytes?: Uint8Array | undefined;
  cloudEvent?:
    | TopicEventCERequest
    | undefined;
  /** content type of the event contained. */
  contentType: string;
  /** The metadata associated with the event. */
  metadata: { [key: string]: string };
}

export interface TopicEventBulkRequestEntry_MetadataEntry {
  key: string;
  value: string;
}

/** TopicEventBulkRequest represents request for bulk message */
export interface TopicEventBulkRequest {
  /** Unique identifier for the bulk request. */
  id: string;
  /** The list of items inside this bulk request. */
  entries: TopicEventBulkRequestEntry[];
  /** The metadata associated with the this bulk request. */
  metadata: { [key: string]: string };
  /** The pubsub topic which publisher sent to. */
  topic: string;
  /** The name of the pubsub the publisher sent to. */
  pubsubName: string;
  /** The type of event related to the originating occurrence. */
  type: string;
  /**
   * The matching path from TopicSubscription/routes (if specified) for this event.
   * This value is used by OnTopicEvent to "switch" inside the handler.
   */
  path: string;
}

export interface TopicEventBulkRequest_MetadataEntry {
  key: string;
  value: string;
}

/**
 * TopicEventBulkResponseEntry Represents single response, as part of TopicEventBulkResponse, to be
 * sent by subscibed App for the corresponding single message during bulk subscribe
 */
export interface TopicEventBulkResponseEntry {
  /** Unique identifier associated the message. */
  entryId: string;
  /** The status of the response. */
  status: TopicEventResponse_TopicEventResponseStatus;
}

/** AppBulkResponse is response from app on published message */
export interface TopicEventBulkResponse {
  /** The list of all responses for the bulk request. */
  statuses: TopicEventBulkResponseEntry[];
}

/** BindingEventRequest represents input bindings event. */
export interface BindingEventRequest {
  /** Required. The name of the input binding component. */
  name: string;
  /** Required. The payload that the input bindings sent */
  data: Uint8Array;
  /** The metadata set by the input binging components. */
  metadata: { [key: string]: string };
}

export interface BindingEventRequest_MetadataEntry {
  key: string;
  value: string;
}

/**
 * BindingEventResponse includes operations to save state or
 * send data to output bindings optionally.
 */
export interface BindingEventResponse {
  /** The name of state store where states are saved. */
  storeName: string;
  /** The state key values which will be stored in store_name. */
  states: StateItem[];
  /** The list of output bindings. */
  to: string[];
  /** The content which will be sent to "to" output bindings. */
  data: Uint8Array;
  /**
   * The concurrency of output bindings to send data to
   * "to" output bindings list. The default is SEQUENTIAL.
   */
  concurrency: BindingEventResponse_BindingEventConcurrency;
}

/** BindingEventConcurrency is the kind of concurrency */
export enum BindingEventResponse_BindingEventConcurrency {
  /** SEQUENTIAL - SEQUENTIAL sends data to output bindings specified in "to" sequentially. */
  SEQUENTIAL = "SEQUENTIAL",
  /** PARALLEL - PARALLEL sends data to output bindings specified in "to" in parallel. */
  PARALLEL = "PARALLEL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function bindingEventResponse_BindingEventConcurrencyFromJSON(
  object: any,
): BindingEventResponse_BindingEventConcurrency {
  switch (object) {
    case 0:
    case "SEQUENTIAL":
      return BindingEventResponse_BindingEventConcurrency.SEQUENTIAL;
    case 1:
    case "PARALLEL":
      return BindingEventResponse_BindingEventConcurrency.PARALLEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BindingEventResponse_BindingEventConcurrency.UNRECOGNIZED;
  }
}

export function bindingEventResponse_BindingEventConcurrencyToJSON(
  object: BindingEventResponse_BindingEventConcurrency,
): string {
  switch (object) {
    case BindingEventResponse_BindingEventConcurrency.SEQUENTIAL:
      return "SEQUENTIAL";
    case BindingEventResponse_BindingEventConcurrency.PARALLEL:
      return "PARALLEL";
    case BindingEventResponse_BindingEventConcurrency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function bindingEventResponse_BindingEventConcurrencyToNumber(
  object: BindingEventResponse_BindingEventConcurrency,
): number {
  switch (object) {
    case BindingEventResponse_BindingEventConcurrency.SEQUENTIAL:
      return 0;
    case BindingEventResponse_BindingEventConcurrency.PARALLEL:
      return 1;
    case BindingEventResponse_BindingEventConcurrency.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** ListTopicSubscriptionsResponse is the message including the list of the subscribing topics. */
export interface ListTopicSubscriptionsResponse {
  /** The list of topics. */
  subscriptions: TopicSubscription[];
}

/** TopicSubscription represents topic and metadata. */
export interface TopicSubscription {
  /** Required. The name of the pubsub containing the topic below to subscribe to. */
  pubsubName: string;
  /** Required. The name of topic which will be subscribed */
  topic: string;
  /** The optional properties used for this topic's subscription e.g. session id */
  metadata: { [key: string]: string };
  /**
   * The optional routing rules to match against. In the gRPC interface, OnTopicEvent
   * is still invoked but the matching path is sent in the TopicEventRequest.
   */
  routes:
    | TopicRoutes
    | undefined;
  /** The optional dead letter queue for this topic to send events to. */
  deadLetterTopic: string;
  /** The optional bulk subscribe settings for this topic. */
  bulkSubscribe: BulkSubscribeConfig | undefined;
}

export interface TopicSubscription_MetadataEntry {
  key: string;
  value: string;
}

export interface TopicRoutes {
  /** The list of rules for this topic. */
  rules: TopicRule[];
  /** The default path for this topic. */
  default: string;
}

export interface TopicRule {
  /**
   * The optional CEL expression used to match the event.
   * If the match is not specified, then the route is considered
   * the default.
   */
  match: string;
  /**
   * The path used to identify matches for this subscription.
   * This value is passed in TopicEventRequest and used by OnTopicEvent to "switch"
   * inside the handler.
   */
  path: string;
}

/** BulkSubscribeConfig is the message to pass settings for bulk subscribe */
export interface BulkSubscribeConfig {
  /** Required. Flag to enable/disable bulk subscribe */
  enabled: boolean;
  /** Optional. Max number of messages to be sent in a single bulk request */
  maxMessagesCount: number;
  /** Optional. Max duration to wait for messages to be sent in a single bulk request */
  maxAwaitDurationMs: number;
}

/** ListInputBindingsResponse is the message including the list of input bindings. */
export interface ListInputBindingsResponse {
  /** The list of input bindings. */
  bindings: string[];
}

/**
 * HealthCheckResponse is the message with the response to the health check.
 * This message is currently empty as used as placeholder.
 */
export interface HealthCheckResponse {
}

function createBaseTopicEventRequest(): TopicEventRequest {
  return {
    id: "",
    source: "",
    type: "",
    specVersion: "",
    dataContentType: "",
    data: new Uint8Array(0),
    topic: "",
    pubsubName: "",
    path: "",
    extensions: undefined,
  };
}

export const TopicEventRequest = {
  encode(message: TopicEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.specVersion !== "") {
      writer.uint32(34).string(message.specVersion);
    }
    if (message.dataContentType !== "") {
      writer.uint32(42).string(message.dataContentType);
    }
    if (message.data.length !== 0) {
      writer.uint32(58).bytes(message.data);
    }
    if (message.topic !== "") {
      writer.uint32(50).string(message.topic);
    }
    if (message.pubsubName !== "") {
      writer.uint32(66).string(message.pubsubName);
    }
    if (message.path !== "") {
      writer.uint32(74).string(message.path);
    }
    if (message.extensions !== undefined) {
      Struct.encode(Struct.wrap(message.extensions), writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.specVersion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dataContentType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.path = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.extensions = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicEventRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<TopicEventRequest | TopicEventRequest[]> | Iterable<TopicEventRequest | TopicEventRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventRequest.encode(p).finish()];
        }
      } else {
        yield* [TopicEventRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicEventRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicEventRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventRequest.decode(p)];
        }
      } else {
        yield* [TopicEventRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicEventRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      specVersion: isSet(object.specVersion) ? globalThis.String(object.specVersion) : "",
      dataContentType: isSet(object.dataContentType) ? globalThis.String(object.dataContentType) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      extensions: isObject(object.extensions) ? object.extensions : undefined,
    };
  },

  toJSON(message: TopicEventRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.specVersion !== "") {
      obj.specVersion = message.specVersion;
    }
    if (message.dataContentType !== "") {
      obj.dataContentType = message.dataContentType;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.extensions !== undefined) {
      obj.extensions = message.extensions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicEventRequest>, I>>(base?: I): TopicEventRequest {
    return TopicEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicEventRequest>, I>>(object: I): TopicEventRequest {
    const message = createBaseTopicEventRequest();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.type = object.type ?? "";
    message.specVersion = object.specVersion ?? "";
    message.dataContentType = object.dataContentType ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.topic = object.topic ?? "";
    message.pubsubName = object.pubsubName ?? "";
    message.path = object.path ?? "";
    message.extensions = object.extensions ?? undefined;
    return message;
  },
};

function createBaseTopicEventResponse(): TopicEventResponse {
  return { status: TopicEventResponse_TopicEventResponseStatus.SUCCESS };
}

export const TopicEventResponse = {
  encode(message: TopicEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== TopicEventResponse_TopicEventResponseStatus.SUCCESS) {
      writer.uint32(8).int32(topicEventResponse_TopicEventResponseStatusToNumber(message.status));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = topicEventResponse_TopicEventResponseStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicEventResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TopicEventResponse | TopicEventResponse[]>
      | Iterable<TopicEventResponse | TopicEventResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventResponse.encode(p).finish()];
        }
      } else {
        yield* [TopicEventResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicEventResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicEventResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventResponse.decode(p)];
        }
      } else {
        yield* [TopicEventResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicEventResponse {
    return {
      status: isSet(object.status)
        ? topicEventResponse_TopicEventResponseStatusFromJSON(object.status)
        : TopicEventResponse_TopicEventResponseStatus.SUCCESS,
    };
  },

  toJSON(message: TopicEventResponse): unknown {
    const obj: any = {};
    if (message.status !== TopicEventResponse_TopicEventResponseStatus.SUCCESS) {
      obj.status = topicEventResponse_TopicEventResponseStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicEventResponse>, I>>(base?: I): TopicEventResponse {
    return TopicEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicEventResponse>, I>>(object: I): TopicEventResponse {
    const message = createBaseTopicEventResponse();
    message.status = object.status ?? TopicEventResponse_TopicEventResponseStatus.SUCCESS;
    return message;
  },
};

function createBaseTopicEventCERequest(): TopicEventCERequest {
  return {
    id: "",
    source: "",
    type: "",
    specVersion: "",
    dataContentType: "",
    data: new Uint8Array(0),
    extensions: undefined,
  };
}

export const TopicEventCERequest = {
  encode(message: TopicEventCERequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.specVersion !== "") {
      writer.uint32(34).string(message.specVersion);
    }
    if (message.dataContentType !== "") {
      writer.uint32(42).string(message.dataContentType);
    }
    if (message.data.length !== 0) {
      writer.uint32(50).bytes(message.data);
    }
    if (message.extensions !== undefined) {
      Struct.encode(Struct.wrap(message.extensions), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventCERequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventCERequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.specVersion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dataContentType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.extensions = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicEventCERequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TopicEventCERequest | TopicEventCERequest[]>
      | Iterable<TopicEventCERequest | TopicEventCERequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventCERequest.encode(p).finish()];
        }
      } else {
        yield* [TopicEventCERequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicEventCERequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicEventCERequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventCERequest.decode(p)];
        }
      } else {
        yield* [TopicEventCERequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicEventCERequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      specVersion: isSet(object.specVersion) ? globalThis.String(object.specVersion) : "",
      dataContentType: isSet(object.dataContentType) ? globalThis.String(object.dataContentType) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      extensions: isObject(object.extensions) ? object.extensions : undefined,
    };
  },

  toJSON(message: TopicEventCERequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.specVersion !== "") {
      obj.specVersion = message.specVersion;
    }
    if (message.dataContentType !== "") {
      obj.dataContentType = message.dataContentType;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.extensions !== undefined) {
      obj.extensions = message.extensions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicEventCERequest>, I>>(base?: I): TopicEventCERequest {
    return TopicEventCERequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicEventCERequest>, I>>(object: I): TopicEventCERequest {
    const message = createBaseTopicEventCERequest();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.type = object.type ?? "";
    message.specVersion = object.specVersion ?? "";
    message.dataContentType = object.dataContentType ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.extensions = object.extensions ?? undefined;
    return message;
  },
};

function createBaseTopicEventBulkRequestEntry(): TopicEventBulkRequestEntry {
  return { entryId: "", bytes: undefined, cloudEvent: undefined, contentType: "", metadata: {} };
}

export const TopicEventBulkRequestEntry = {
  encode(message: TopicEventBulkRequestEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entryId !== "") {
      writer.uint32(10).string(message.entryId);
    }
    if (message.bytes !== undefined) {
      writer.uint32(18).bytes(message.bytes);
    }
    if (message.cloudEvent !== undefined) {
      TopicEventCERequest.encode(message.cloudEvent, writer.uint32(26).fork()).ldelim();
    }
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TopicEventBulkRequestEntry_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkRequestEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkRequestEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bytes = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cloudEvent = TopicEventCERequest.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = TopicEventBulkRequestEntry_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicEventBulkRequestEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TopicEventBulkRequestEntry | TopicEventBulkRequestEntry[]>
      | Iterable<TopicEventBulkRequestEntry | TopicEventBulkRequestEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkRequestEntry.encode(p).finish()];
        }
      } else {
        yield* [TopicEventBulkRequestEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicEventBulkRequestEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicEventBulkRequestEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkRequestEntry.decode(p)];
        }
      } else {
        yield* [TopicEventBulkRequestEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicEventBulkRequestEntry {
    return {
      entryId: isSet(object.entryId) ? globalThis.String(object.entryId) : "",
      bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : undefined,
      cloudEvent: isSet(object.cloudEvent) ? TopicEventCERequest.fromJSON(object.cloudEvent) : undefined,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TopicEventBulkRequestEntry): unknown {
    const obj: any = {};
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.bytes !== undefined) {
      obj.bytes = base64FromBytes(message.bytes);
    }
    if (message.cloudEvent !== undefined) {
      obj.cloudEvent = TopicEventCERequest.toJSON(message.cloudEvent);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicEventBulkRequestEntry>, I>>(base?: I): TopicEventBulkRequestEntry {
    return TopicEventBulkRequestEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicEventBulkRequestEntry>, I>>(object: I): TopicEventBulkRequestEntry {
    const message = createBaseTopicEventBulkRequestEntry();
    message.entryId = object.entryId ?? "";
    message.bytes = object.bytes ?? undefined;
    message.cloudEvent = (object.cloudEvent !== undefined && object.cloudEvent !== null)
      ? TopicEventCERequest.fromPartial(object.cloudEvent)
      : undefined;
    message.contentType = object.contentType ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTopicEventBulkRequestEntry_MetadataEntry(): TopicEventBulkRequestEntry_MetadataEntry {
  return { key: "", value: "" };
}

export const TopicEventBulkRequestEntry_MetadataEntry = {
  encode(message: TopicEventBulkRequestEntry_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkRequestEntry_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkRequestEntry_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicEventBulkRequestEntry_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TopicEventBulkRequestEntry_MetadataEntry | TopicEventBulkRequestEntry_MetadataEntry[]>
      | Iterable<TopicEventBulkRequestEntry_MetadataEntry | TopicEventBulkRequestEntry_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkRequestEntry_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [TopicEventBulkRequestEntry_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicEventBulkRequestEntry_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicEventBulkRequestEntry_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkRequestEntry_MetadataEntry.decode(p)];
        }
      } else {
        yield* [TopicEventBulkRequestEntry_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicEventBulkRequestEntry_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TopicEventBulkRequestEntry_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicEventBulkRequestEntry_MetadataEntry>, I>>(
    base?: I,
  ): TopicEventBulkRequestEntry_MetadataEntry {
    return TopicEventBulkRequestEntry_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicEventBulkRequestEntry_MetadataEntry>, I>>(
    object: I,
  ): TopicEventBulkRequestEntry_MetadataEntry {
    const message = createBaseTopicEventBulkRequestEntry_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTopicEventBulkRequest(): TopicEventBulkRequest {
  return { id: "", entries: [], metadata: {}, topic: "", pubsubName: "", type: "", path: "" };
}

export const TopicEventBulkRequest = {
  encode(message: TopicEventBulkRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.entries) {
      TopicEventBulkRequestEntry.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TopicEventBulkRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.topic !== "") {
      writer.uint32(34).string(message.topic);
    }
    if (message.pubsubName !== "") {
      writer.uint32(42).string(message.pubsubName);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    if (message.path !== "") {
      writer.uint32(58).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entries.push(TopicEventBulkRequestEntry.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = TopicEventBulkRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicEventBulkRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TopicEventBulkRequest | TopicEventBulkRequest[]>
      | Iterable<TopicEventBulkRequest | TopicEventBulkRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkRequest.encode(p).finish()];
        }
      } else {
        yield* [TopicEventBulkRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicEventBulkRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicEventBulkRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkRequest.decode(p)];
        }
      } else {
        yield* [TopicEventBulkRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicEventBulkRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => TopicEventBulkRequestEntry.fromJSON(e))
        : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: TopicEventBulkRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => TopicEventBulkRequestEntry.toJSON(e));
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicEventBulkRequest>, I>>(base?: I): TopicEventBulkRequest {
    return TopicEventBulkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicEventBulkRequest>, I>>(object: I): TopicEventBulkRequest {
    const message = createBaseTopicEventBulkRequest();
    message.id = object.id ?? "";
    message.entries = object.entries?.map((e) => TopicEventBulkRequestEntry.fromPartial(e)) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.topic = object.topic ?? "";
    message.pubsubName = object.pubsubName ?? "";
    message.type = object.type ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseTopicEventBulkRequest_MetadataEntry(): TopicEventBulkRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const TopicEventBulkRequest_MetadataEntry = {
  encode(message: TopicEventBulkRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicEventBulkRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TopicEventBulkRequest_MetadataEntry | TopicEventBulkRequest_MetadataEntry[]>
      | Iterable<TopicEventBulkRequest_MetadataEntry | TopicEventBulkRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [TopicEventBulkRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicEventBulkRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicEventBulkRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [TopicEventBulkRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicEventBulkRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TopicEventBulkRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicEventBulkRequest_MetadataEntry>, I>>(
    base?: I,
  ): TopicEventBulkRequest_MetadataEntry {
    return TopicEventBulkRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicEventBulkRequest_MetadataEntry>, I>>(
    object: I,
  ): TopicEventBulkRequest_MetadataEntry {
    const message = createBaseTopicEventBulkRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTopicEventBulkResponseEntry(): TopicEventBulkResponseEntry {
  return { entryId: "", status: TopicEventResponse_TopicEventResponseStatus.SUCCESS };
}

export const TopicEventBulkResponseEntry = {
  encode(message: TopicEventBulkResponseEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entryId !== "") {
      writer.uint32(10).string(message.entryId);
    }
    if (message.status !== TopicEventResponse_TopicEventResponseStatus.SUCCESS) {
      writer.uint32(16).int32(topicEventResponse_TopicEventResponseStatusToNumber(message.status));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkResponseEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkResponseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = topicEventResponse_TopicEventResponseStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicEventBulkResponseEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TopicEventBulkResponseEntry | TopicEventBulkResponseEntry[]>
      | Iterable<TopicEventBulkResponseEntry | TopicEventBulkResponseEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkResponseEntry.encode(p).finish()];
        }
      } else {
        yield* [TopicEventBulkResponseEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicEventBulkResponseEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicEventBulkResponseEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkResponseEntry.decode(p)];
        }
      } else {
        yield* [TopicEventBulkResponseEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicEventBulkResponseEntry {
    return {
      entryId: isSet(object.entryId) ? globalThis.String(object.entryId) : "",
      status: isSet(object.status)
        ? topicEventResponse_TopicEventResponseStatusFromJSON(object.status)
        : TopicEventResponse_TopicEventResponseStatus.SUCCESS,
    };
  },

  toJSON(message: TopicEventBulkResponseEntry): unknown {
    const obj: any = {};
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.status !== TopicEventResponse_TopicEventResponseStatus.SUCCESS) {
      obj.status = topicEventResponse_TopicEventResponseStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicEventBulkResponseEntry>, I>>(base?: I): TopicEventBulkResponseEntry {
    return TopicEventBulkResponseEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicEventBulkResponseEntry>, I>>(object: I): TopicEventBulkResponseEntry {
    const message = createBaseTopicEventBulkResponseEntry();
    message.entryId = object.entryId ?? "";
    message.status = object.status ?? TopicEventResponse_TopicEventResponseStatus.SUCCESS;
    return message;
  },
};

function createBaseTopicEventBulkResponse(): TopicEventBulkResponse {
  return { statuses: [] };
}

export const TopicEventBulkResponse = {
  encode(message: TopicEventBulkResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.statuses) {
      TopicEventBulkResponseEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.statuses.push(TopicEventBulkResponseEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicEventBulkResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TopicEventBulkResponse | TopicEventBulkResponse[]>
      | Iterable<TopicEventBulkResponse | TopicEventBulkResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkResponse.encode(p).finish()];
        }
      } else {
        yield* [TopicEventBulkResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicEventBulkResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicEventBulkResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicEventBulkResponse.decode(p)];
        }
      } else {
        yield* [TopicEventBulkResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicEventBulkResponse {
    return {
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => TopicEventBulkResponseEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TopicEventBulkResponse): unknown {
    const obj: any = {};
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => TopicEventBulkResponseEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicEventBulkResponse>, I>>(base?: I): TopicEventBulkResponse {
    return TopicEventBulkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicEventBulkResponse>, I>>(object: I): TopicEventBulkResponse {
    const message = createBaseTopicEventBulkResponse();
    message.statuses = object.statuses?.map((e) => TopicEventBulkResponseEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBindingEventRequest(): BindingEventRequest {
  return { name: "", data: new Uint8Array(0), metadata: {} };
}

export const BindingEventRequest = {
  encode(message: BindingEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      BindingEventRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BindingEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindingEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = BindingEventRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BindingEventRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BindingEventRequest | BindingEventRequest[]>
      | Iterable<BindingEventRequest | BindingEventRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BindingEventRequest.encode(p).finish()];
        }
      } else {
        yield* [BindingEventRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BindingEventRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BindingEventRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BindingEventRequest.decode(p)];
        }
      } else {
        yield* [BindingEventRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BindingEventRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BindingEventRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BindingEventRequest>, I>>(base?: I): BindingEventRequest {
    return BindingEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BindingEventRequest>, I>>(object: I): BindingEventRequest {
    const message = createBaseBindingEventRequest();
    message.name = object.name ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBindingEventRequest_MetadataEntry(): BindingEventRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const BindingEventRequest_MetadataEntry = {
  encode(message: BindingEventRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BindingEventRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindingEventRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BindingEventRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BindingEventRequest_MetadataEntry | BindingEventRequest_MetadataEntry[]>
      | Iterable<BindingEventRequest_MetadataEntry | BindingEventRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BindingEventRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [BindingEventRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BindingEventRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BindingEventRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BindingEventRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [BindingEventRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BindingEventRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BindingEventRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BindingEventRequest_MetadataEntry>, I>>(
    base?: I,
  ): BindingEventRequest_MetadataEntry {
    return BindingEventRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BindingEventRequest_MetadataEntry>, I>>(
    object: I,
  ): BindingEventRequest_MetadataEntry {
    const message = createBaseBindingEventRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBindingEventResponse(): BindingEventResponse {
  return {
    storeName: "",
    states: [],
    to: [],
    data: new Uint8Array(0),
    concurrency: BindingEventResponse_BindingEventConcurrency.SEQUENTIAL,
  };
}

export const BindingEventResponse = {
  encode(message: BindingEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    for (const v of message.states) {
      StateItem.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.to) {
      writer.uint32(26).string(v!);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    if (message.concurrency !== BindingEventResponse_BindingEventConcurrency.SEQUENTIAL) {
      writer.uint32(40).int32(bindingEventResponse_BindingEventConcurrencyToNumber(message.concurrency));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BindingEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindingEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.states.push(StateItem.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.concurrency = bindingEventResponse_BindingEventConcurrencyFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BindingEventResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BindingEventResponse | BindingEventResponse[]>
      | Iterable<BindingEventResponse | BindingEventResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BindingEventResponse.encode(p).finish()];
        }
      } else {
        yield* [BindingEventResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BindingEventResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BindingEventResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BindingEventResponse.decode(p)];
        }
      } else {
        yield* [BindingEventResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BindingEventResponse {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      states: globalThis.Array.isArray(object?.states) ? object.states.map((e: any) => StateItem.fromJSON(e)) : [],
      to: globalThis.Array.isArray(object?.to) ? object.to.map((e: any) => globalThis.String(e)) : [],
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      concurrency: isSet(object.concurrency)
        ? bindingEventResponse_BindingEventConcurrencyFromJSON(object.concurrency)
        : BindingEventResponse_BindingEventConcurrency.SEQUENTIAL,
    };
  },

  toJSON(message: BindingEventResponse): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.states?.length) {
      obj.states = message.states.map((e) => StateItem.toJSON(e));
    }
    if (message.to?.length) {
      obj.to = message.to;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.concurrency !== BindingEventResponse_BindingEventConcurrency.SEQUENTIAL) {
      obj.concurrency = bindingEventResponse_BindingEventConcurrencyToJSON(message.concurrency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BindingEventResponse>, I>>(base?: I): BindingEventResponse {
    return BindingEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BindingEventResponse>, I>>(object: I): BindingEventResponse {
    const message = createBaseBindingEventResponse();
    message.storeName = object.storeName ?? "";
    message.states = object.states?.map((e) => StateItem.fromPartial(e)) || [];
    message.to = object.to?.map((e) => e) || [];
    message.data = object.data ?? new Uint8Array(0);
    message.concurrency = object.concurrency ?? BindingEventResponse_BindingEventConcurrency.SEQUENTIAL;
    return message;
  },
};

function createBaseListTopicSubscriptionsResponse(): ListTopicSubscriptionsResponse {
  return { subscriptions: [] };
}

export const ListTopicSubscriptionsResponse = {
  encode(message: ListTopicSubscriptionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.subscriptions) {
      TopicSubscription.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTopicSubscriptionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(TopicSubscription.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListTopicSubscriptionsResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListTopicSubscriptionsResponse | ListTopicSubscriptionsResponse[]>
      | Iterable<ListTopicSubscriptionsResponse | ListTopicSubscriptionsResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListTopicSubscriptionsResponse.encode(p).finish()];
        }
      } else {
        yield* [ListTopicSubscriptionsResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListTopicSubscriptionsResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListTopicSubscriptionsResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListTopicSubscriptionsResponse.decode(p)];
        }
      } else {
        yield* [ListTopicSubscriptionsResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListTopicSubscriptionsResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => TopicSubscription.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListTopicSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => TopicSubscription.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopicSubscriptionsResponse>, I>>(base?: I): ListTopicSubscriptionsResponse {
    return ListTopicSubscriptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopicSubscriptionsResponse>, I>>(
    object: I,
  ): ListTopicSubscriptionsResponse {
    const message = createBaseListTopicSubscriptionsResponse();
    message.subscriptions = object.subscriptions?.map((e) => TopicSubscription.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTopicSubscription(): TopicSubscription {
  return { pubsubName: "", topic: "", metadata: {}, routes: undefined, deadLetterTopic: "", bulkSubscribe: undefined };
}

export const TopicSubscription = {
  encode(message: TopicSubscription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pubsubName !== "") {
      writer.uint32(10).string(message.pubsubName);
    }
    if (message.topic !== "") {
      writer.uint32(18).string(message.topic);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TopicSubscription_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.routes !== undefined) {
      TopicRoutes.encode(message.routes, writer.uint32(42).fork()).ldelim();
    }
    if (message.deadLetterTopic !== "") {
      writer.uint32(50).string(message.deadLetterTopic);
    }
    if (message.bulkSubscribe !== undefined) {
      BulkSubscribeConfig.encode(message.bulkSubscribe, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicSubscription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = TopicSubscription_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.routes = TopicRoutes.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.deadLetterTopic = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.bulkSubscribe = BulkSubscribeConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicSubscription, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<TopicSubscription | TopicSubscription[]> | Iterable<TopicSubscription | TopicSubscription[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicSubscription.encode(p).finish()];
        }
      } else {
        yield* [TopicSubscription.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicSubscription>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicSubscription> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicSubscription.decode(p)];
        }
      } else {
        yield* [TopicSubscription.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicSubscription {
    return {
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      routes: isSet(object.routes) ? TopicRoutes.fromJSON(object.routes) : undefined,
      deadLetterTopic: isSet(object.deadLetterTopic) ? globalThis.String(object.deadLetterTopic) : "",
      bulkSubscribe: isSet(object.bulkSubscribe) ? BulkSubscribeConfig.fromJSON(object.bulkSubscribe) : undefined,
    };
  },

  toJSON(message: TopicSubscription): unknown {
    const obj: any = {};
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.routes !== undefined) {
      obj.routes = TopicRoutes.toJSON(message.routes);
    }
    if (message.deadLetterTopic !== "") {
      obj.deadLetterTopic = message.deadLetterTopic;
    }
    if (message.bulkSubscribe !== undefined) {
      obj.bulkSubscribe = BulkSubscribeConfig.toJSON(message.bulkSubscribe);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicSubscription>, I>>(base?: I): TopicSubscription {
    return TopicSubscription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicSubscription>, I>>(object: I): TopicSubscription {
    const message = createBaseTopicSubscription();
    message.pubsubName = object.pubsubName ?? "";
    message.topic = object.topic ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.routes = (object.routes !== undefined && object.routes !== null)
      ? TopicRoutes.fromPartial(object.routes)
      : undefined;
    message.deadLetterTopic = object.deadLetterTopic ?? "";
    message.bulkSubscribe = (object.bulkSubscribe !== undefined && object.bulkSubscribe !== null)
      ? BulkSubscribeConfig.fromPartial(object.bulkSubscribe)
      : undefined;
    return message;
  },
};

function createBaseTopicSubscription_MetadataEntry(): TopicSubscription_MetadataEntry {
  return { key: "", value: "" };
}

export const TopicSubscription_MetadataEntry = {
  encode(message: TopicSubscription_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicSubscription_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicSubscription_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicSubscription_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<TopicSubscription_MetadataEntry | TopicSubscription_MetadataEntry[]>
      | Iterable<TopicSubscription_MetadataEntry | TopicSubscription_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicSubscription_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [TopicSubscription_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicSubscription_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicSubscription_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicSubscription_MetadataEntry.decode(p)];
        }
      } else {
        yield* [TopicSubscription_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicSubscription_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TopicSubscription_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicSubscription_MetadataEntry>, I>>(base?: I): TopicSubscription_MetadataEntry {
    return TopicSubscription_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicSubscription_MetadataEntry>, I>>(
    object: I,
  ): TopicSubscription_MetadataEntry {
    const message = createBaseTopicSubscription_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTopicRoutes(): TopicRoutes {
  return { rules: [], default: "" };
}

export const TopicRoutes = {
  encode(message: TopicRoutes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rules) {
      TopicRule.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.default !== "") {
      writer.uint32(18).string(message.default);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicRoutes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicRoutes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rules.push(TopicRule.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.default = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicRoutes, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<TopicRoutes | TopicRoutes[]> | Iterable<TopicRoutes | TopicRoutes[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicRoutes.encode(p).finish()];
        }
      } else {
        yield* [TopicRoutes.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicRoutes>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicRoutes> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicRoutes.decode(p)];
        }
      } else {
        yield* [TopicRoutes.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicRoutes {
    return {
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => TopicRule.fromJSON(e)) : [],
      default: isSet(object.default) ? globalThis.String(object.default) : "",
    };
  },

  toJSON(message: TopicRoutes): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => TopicRule.toJSON(e));
    }
    if (message.default !== "") {
      obj.default = message.default;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicRoutes>, I>>(base?: I): TopicRoutes {
    return TopicRoutes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicRoutes>, I>>(object: I): TopicRoutes {
    const message = createBaseTopicRoutes();
    message.rules = object.rules?.map((e) => TopicRule.fromPartial(e)) || [];
    message.default = object.default ?? "";
    return message;
  },
};

function createBaseTopicRule(): TopicRule {
  return { match: "", path: "" };
}

export const TopicRule = {
  encode(message: TopicRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.match !== "") {
      writer.uint32(10).string(message.match);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.match = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<TopicRule, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<TopicRule | TopicRule[]> | Iterable<TopicRule | TopicRule[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicRule.encode(p).finish()];
        }
      } else {
        yield* [TopicRule.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, TopicRule>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<TopicRule> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [TopicRule.decode(p)];
        }
      } else {
        yield* [TopicRule.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): TopicRule {
    return {
      match: isSet(object.match) ? globalThis.String(object.match) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: TopicRule): unknown {
    const obj: any = {};
    if (message.match !== "") {
      obj.match = message.match;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopicRule>, I>>(base?: I): TopicRule {
    return TopicRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopicRule>, I>>(object: I): TopicRule {
    const message = createBaseTopicRule();
    message.match = object.match ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseBulkSubscribeConfig(): BulkSubscribeConfig {
  return { enabled: false, maxMessagesCount: 0, maxAwaitDurationMs: 0 };
}

export const BulkSubscribeConfig = {
  encode(message: BulkSubscribeConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.maxMessagesCount !== 0) {
      writer.uint32(16).int32(message.maxMessagesCount);
    }
    if (message.maxAwaitDurationMs !== 0) {
      writer.uint32(24).int32(message.maxAwaitDurationMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkSubscribeConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkSubscribeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxMessagesCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxAwaitDurationMs = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<BulkSubscribeConfig, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<BulkSubscribeConfig | BulkSubscribeConfig[]>
      | Iterable<BulkSubscribeConfig | BulkSubscribeConfig[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkSubscribeConfig.encode(p).finish()];
        }
      } else {
        yield* [BulkSubscribeConfig.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, BulkSubscribeConfig>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<BulkSubscribeConfig> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [BulkSubscribeConfig.decode(p)];
        }
      } else {
        yield* [BulkSubscribeConfig.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): BulkSubscribeConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      maxMessagesCount: isSet(object.maxMessagesCount) ? globalThis.Number(object.maxMessagesCount) : 0,
      maxAwaitDurationMs: isSet(object.maxAwaitDurationMs) ? globalThis.Number(object.maxAwaitDurationMs) : 0,
    };
  },

  toJSON(message: BulkSubscribeConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.maxMessagesCount !== 0) {
      obj.maxMessagesCount = Math.round(message.maxMessagesCount);
    }
    if (message.maxAwaitDurationMs !== 0) {
      obj.maxAwaitDurationMs = Math.round(message.maxAwaitDurationMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkSubscribeConfig>, I>>(base?: I): BulkSubscribeConfig {
    return BulkSubscribeConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkSubscribeConfig>, I>>(object: I): BulkSubscribeConfig {
    const message = createBaseBulkSubscribeConfig();
    message.enabled = object.enabled ?? false;
    message.maxMessagesCount = object.maxMessagesCount ?? 0;
    message.maxAwaitDurationMs = object.maxAwaitDurationMs ?? 0;
    return message;
  },
};

function createBaseListInputBindingsResponse(): ListInputBindingsResponse {
  return { bindings: [] };
}

export const ListInputBindingsResponse = {
  encode(message: ListInputBindingsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.bindings) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListInputBindingsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInputBindingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bindings.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListInputBindingsResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListInputBindingsResponse | ListInputBindingsResponse[]>
      | Iterable<ListInputBindingsResponse | ListInputBindingsResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListInputBindingsResponse.encode(p).finish()];
        }
      } else {
        yield* [ListInputBindingsResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListInputBindingsResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListInputBindingsResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListInputBindingsResponse.decode(p)];
        }
      } else {
        yield* [ListInputBindingsResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListInputBindingsResponse {
    return {
      bindings: globalThis.Array.isArray(object?.bindings) ? object.bindings.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListInputBindingsResponse): unknown {
    const obj: any = {};
    if (message.bindings?.length) {
      obj.bindings = message.bindings;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInputBindingsResponse>, I>>(base?: I): ListInputBindingsResponse {
    return ListInputBindingsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInputBindingsResponse>, I>>(object: I): ListInputBindingsResponse {
    const message = createBaseListInputBindingsResponse();
    message.bindings = object.bindings?.map((e) => e) || [];
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return {};
}

export const HealthCheckResponse = {
  encode(_: HealthCheckResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<HealthCheckResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<HealthCheckResponse | HealthCheckResponse[]>
      | Iterable<HealthCheckResponse | HealthCheckResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [HealthCheckResponse.encode(p).finish()];
        }
      } else {
        yield* [HealthCheckResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, HealthCheckResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<HealthCheckResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [HealthCheckResponse.decode(p)];
        }
      } else {
        yield* [HealthCheckResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(_: any): HealthCheckResponse {
    return {};
  },

  toJSON(_: HealthCheckResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(_: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    return message;
  },
};

/**
 * AppCallback V1 allows user application to interact with Dapr runtime.
 * User application needs to implement AppCallback service if it needs to
 * receive message from dapr runtime.
 */
export type AppCallbackService = typeof AppCallbackService;
export const AppCallbackService = {
  /** Invokes service method with InvokeRequest. */
  onInvoke: {
    path: "/dapr.proto.runtime.v1.AppCallback/OnInvoke",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InvokeRequest) => Buffer.from(InvokeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InvokeRequest.decode(value),
    responseSerialize: (value: InvokeResponse) => Buffer.from(InvokeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InvokeResponse.decode(value),
  },
  /** Lists all topics subscribed by this app. */
  listTopicSubscriptions: {
    path: "/dapr.proto.runtime.v1.AppCallback/ListTopicSubscriptions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ListTopicSubscriptionsResponse) =>
      Buffer.from(ListTopicSubscriptionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListTopicSubscriptionsResponse.decode(value),
  },
  /** Subscribes events from Pubsub */
  onTopicEvent: {
    path: "/dapr.proto.runtime.v1.AppCallback/OnTopicEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TopicEventRequest) => Buffer.from(TopicEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TopicEventRequest.decode(value),
    responseSerialize: (value: TopicEventResponse) => Buffer.from(TopicEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TopicEventResponse.decode(value),
  },
  /** Lists all input bindings subscribed by this app. */
  listInputBindings: {
    path: "/dapr.proto.runtime.v1.AppCallback/ListInputBindings",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ListInputBindingsResponse) =>
      Buffer.from(ListInputBindingsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListInputBindingsResponse.decode(value),
  },
  /**
   * Listens events from the input bindings
   *
   * User application can save the states or send the events to the output
   * bindings optionally by returning BindingEventResponse.
   */
  onBindingEvent: {
    path: "/dapr.proto.runtime.v1.AppCallback/OnBindingEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BindingEventRequest) => Buffer.from(BindingEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BindingEventRequest.decode(value),
    responseSerialize: (value: BindingEventResponse) => Buffer.from(BindingEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BindingEventResponse.decode(value),
  },
} as const;

export interface AppCallbackServer extends UntypedServiceImplementation {
  /** Invokes service method with InvokeRequest. */
  onInvoke: handleUnaryCall<InvokeRequest, InvokeResponse>;
  /** Lists all topics subscribed by this app. */
  listTopicSubscriptions: handleUnaryCall<Empty, ListTopicSubscriptionsResponse>;
  /** Subscribes events from Pubsub */
  onTopicEvent: handleUnaryCall<TopicEventRequest, TopicEventResponse>;
  /** Lists all input bindings subscribed by this app. */
  listInputBindings: handleUnaryCall<Empty, ListInputBindingsResponse>;
  /**
   * Listens events from the input bindings
   *
   * User application can save the states or send the events to the output
   * bindings optionally by returning BindingEventResponse.
   */
  onBindingEvent: handleUnaryCall<BindingEventRequest, BindingEventResponse>;
}

export interface AppCallbackClient extends Client {
  /** Invokes service method with InvokeRequest. */
  onInvoke(
    request: InvokeRequest,
    callback: (error: ServiceError | null, response: InvokeResponse) => void,
  ): ClientUnaryCall;
  onInvoke(
    request: InvokeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InvokeResponse) => void,
  ): ClientUnaryCall;
  onInvoke(
    request: InvokeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InvokeResponse) => void,
  ): ClientUnaryCall;
  /** Lists all topics subscribed by this app. */
  listTopicSubscriptions(
    request: Empty,
    callback: (error: ServiceError | null, response: ListTopicSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  listTopicSubscriptions(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListTopicSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  listTopicSubscriptions(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListTopicSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  /** Subscribes events from Pubsub */
  onTopicEvent(
    request: TopicEventRequest,
    callback: (error: ServiceError | null, response: TopicEventResponse) => void,
  ): ClientUnaryCall;
  onTopicEvent(
    request: TopicEventRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TopicEventResponse) => void,
  ): ClientUnaryCall;
  onTopicEvent(
    request: TopicEventRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TopicEventResponse) => void,
  ): ClientUnaryCall;
  /** Lists all input bindings subscribed by this app. */
  listInputBindings(
    request: Empty,
    callback: (error: ServiceError | null, response: ListInputBindingsResponse) => void,
  ): ClientUnaryCall;
  listInputBindings(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListInputBindingsResponse) => void,
  ): ClientUnaryCall;
  listInputBindings(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListInputBindingsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Listens events from the input bindings
   *
   * User application can save the states or send the events to the output
   * bindings optionally by returning BindingEventResponse.
   */
  onBindingEvent(
    request: BindingEventRequest,
    callback: (error: ServiceError | null, response: BindingEventResponse) => void,
  ): ClientUnaryCall;
  onBindingEvent(
    request: BindingEventRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BindingEventResponse) => void,
  ): ClientUnaryCall;
  onBindingEvent(
    request: BindingEventRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BindingEventResponse) => void,
  ): ClientUnaryCall;
}

export const AppCallbackClient = makeGenericClientConstructor(
  AppCallbackService,
  "dapr.proto.runtime.v1.AppCallback",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AppCallbackClient;
  service: typeof AppCallbackService;
  serviceName: string;
};

/**
 * AppCallbackHealthCheck V1 is an optional extension to AppCallback V1 to implement
 * the HealthCheck method.
 */
export type AppCallbackHealthCheckService = typeof AppCallbackHealthCheckService;
export const AppCallbackHealthCheckService = {
  /** Health check. */
  healthCheck: {
    path: "/dapr.proto.runtime.v1.AppCallbackHealthCheck/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface AppCallbackHealthCheckServer extends UntypedServiceImplementation {
  /** Health check. */
  healthCheck: handleUnaryCall<Empty, HealthCheckResponse>;
}

export interface AppCallbackHealthCheckClient extends Client {
  /** Health check. */
  healthCheck(
    request: Empty,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
}

export const AppCallbackHealthCheckClient = makeGenericClientConstructor(
  AppCallbackHealthCheckService,
  "dapr.proto.runtime.v1.AppCallbackHealthCheck",
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): AppCallbackHealthCheckClient;
  service: typeof AppCallbackHealthCheckService;
  serviceName: string;
};

/**
 * AppCallbackAlpha V1 is an optional extension to AppCallback V1 to opt
 * for Alpha RPCs.
 */
export type AppCallbackAlphaService = typeof AppCallbackAlphaService;
export const AppCallbackAlphaService = {
  /** Subscribes bulk events from Pubsub */
  onBulkTopicEventAlpha1: {
    path: "/dapr.proto.runtime.v1.AppCallbackAlpha/OnBulkTopicEventAlpha1",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TopicEventBulkRequest) => Buffer.from(TopicEventBulkRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TopicEventBulkRequest.decode(value),
    responseSerialize: (value: TopicEventBulkResponse) => Buffer.from(TopicEventBulkResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TopicEventBulkResponse.decode(value),
  },
} as const;

export interface AppCallbackAlphaServer extends UntypedServiceImplementation {
  /** Subscribes bulk events from Pubsub */
  onBulkTopicEventAlpha1: handleUnaryCall<TopicEventBulkRequest, TopicEventBulkResponse>;
}

export interface AppCallbackAlphaClient extends Client {
  /** Subscribes bulk events from Pubsub */
  onBulkTopicEventAlpha1(
    request: TopicEventBulkRequest,
    callback: (error: ServiceError | null, response: TopicEventBulkResponse) => void,
  ): ClientUnaryCall;
  onBulkTopicEventAlpha1(
    request: TopicEventBulkRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TopicEventBulkResponse) => void,
  ): ClientUnaryCall;
  onBulkTopicEventAlpha1(
    request: TopicEventBulkRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TopicEventBulkResponse) => void,
  ): ClientUnaryCall;
}

export const AppCallbackAlphaClient = makeGenericClientConstructor(
  AppCallbackAlphaService,
  "dapr.proto.runtime.v1.AppCallbackAlpha",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AppCallbackAlphaClient;
  service: typeof AppCallbackAlphaService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
