// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.19.1
// source: dapr/proto/common/v1/common.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Any } from "../../../../google/protobuf/any";

export const protobufPackage = "dapr.proto.common.v1";

/**
 * HTTPExtension includes HTTP verb and querystring
 * when Dapr runtime delivers HTTP content.
 *
 * For example, when callers calls http invoke api
 * POST http://localhost:3500/v1.0/invoke/<app_id>/method/<method>?query1=value1&query2=value2
 *
 * Dapr runtime will parse POST as a verb and extract querystring to quersytring map.
 */
export interface HTTPExtension {
  /** Required. HTTP verb. */
  verb: HTTPExtension_Verb;
  /** Optional. querystring represents an encoded HTTP url query string in the following format: name=value&name2=value2 */
  querystring: string;
}

/**
 * Type of HTTP 1.1 Methods
 * RFC 7231: https://tools.ietf.org/html/rfc7231#page-24
 * RFC 5789: https://datatracker.ietf.org/doc/html/rfc5789
 */
export enum HTTPExtension_Verb {
  NONE = "NONE",
  GET = "GET",
  HEAD = "HEAD",
  POST = "POST",
  PUT = "PUT",
  DELETE = "DELETE",
  CONNECT = "CONNECT",
  OPTIONS = "OPTIONS",
  TRACE = "TRACE",
  PATCH = "PATCH",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function hTTPExtension_VerbFromJSON(object: any): HTTPExtension_Verb {
  switch (object) {
    case 0:
    case "NONE":
      return HTTPExtension_Verb.NONE;
    case 1:
    case "GET":
      return HTTPExtension_Verb.GET;
    case 2:
    case "HEAD":
      return HTTPExtension_Verb.HEAD;
    case 3:
    case "POST":
      return HTTPExtension_Verb.POST;
    case 4:
    case "PUT":
      return HTTPExtension_Verb.PUT;
    case 5:
    case "DELETE":
      return HTTPExtension_Verb.DELETE;
    case 6:
    case "CONNECT":
      return HTTPExtension_Verb.CONNECT;
    case 7:
    case "OPTIONS":
      return HTTPExtension_Verb.OPTIONS;
    case 8:
    case "TRACE":
      return HTTPExtension_Verb.TRACE;
    case 9:
    case "PATCH":
      return HTTPExtension_Verb.PATCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HTTPExtension_Verb.UNRECOGNIZED;
  }
}

export function hTTPExtension_VerbToJSON(object: HTTPExtension_Verb): string {
  switch (object) {
    case HTTPExtension_Verb.NONE:
      return "NONE";
    case HTTPExtension_Verb.GET:
      return "GET";
    case HTTPExtension_Verb.HEAD:
      return "HEAD";
    case HTTPExtension_Verb.POST:
      return "POST";
    case HTTPExtension_Verb.PUT:
      return "PUT";
    case HTTPExtension_Verb.DELETE:
      return "DELETE";
    case HTTPExtension_Verb.CONNECT:
      return "CONNECT";
    case HTTPExtension_Verb.OPTIONS:
      return "OPTIONS";
    case HTTPExtension_Verb.TRACE:
      return "TRACE";
    case HTTPExtension_Verb.PATCH:
      return "PATCH";
    case HTTPExtension_Verb.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function hTTPExtension_VerbToNumber(object: HTTPExtension_Verb): number {
  switch (object) {
    case HTTPExtension_Verb.NONE:
      return 0;
    case HTTPExtension_Verb.GET:
      return 1;
    case HTTPExtension_Verb.HEAD:
      return 2;
    case HTTPExtension_Verb.POST:
      return 3;
    case HTTPExtension_Verb.PUT:
      return 4;
    case HTTPExtension_Verb.DELETE:
      return 5;
    case HTTPExtension_Verb.CONNECT:
      return 6;
    case HTTPExtension_Verb.OPTIONS:
      return 7;
    case HTTPExtension_Verb.TRACE:
      return 8;
    case HTTPExtension_Verb.PATCH:
      return 9;
    case HTTPExtension_Verb.UNRECOGNIZED:
    default:
      return -1;
  }
}

/**
 * InvokeRequest is the message to invoke a method with the data.
 * This message is used in InvokeService of Dapr gRPC Service and OnInvoke
 * of AppCallback gRPC service.
 */
export interface InvokeRequest {
  /** Required. method is a method name which will be invoked by caller. */
  method: string;
  /**
   * Required in unary RPCs. Bytes value or Protobuf message which caller sent.
   * Dapr treats Any.value as bytes type if Any.type_url is unset.
   */
  data:
    | Any
    | undefined;
  /**
   * The type of data content.
   *
   * This field is required if data delivers http request body
   * Otherwise, this is optional.
   */
  contentType: string;
  /**
   * HTTP specific fields if request conveys http-compatible request.
   *
   * This field is required for http-compatible request. Otherwise,
   * this field is optional.
   */
  httpExtension: HTTPExtension | undefined;
}

/**
 * InvokeResponse is the response message including data and its content type
 * from app callback.
 * This message is used in InvokeService of Dapr gRPC Service and OnInvoke
 * of AppCallback gRPC service.
 */
export interface InvokeResponse {
  /** Required in unary RPCs. The content body of InvokeService response. */
  data:
    | Any
    | undefined;
  /** Required. The type of data content. */
  contentType: string;
}

/**
 * Chunk of data sent in a streaming request or response.
 * This is used in requests including InternalInvokeRequestStream.
 */
export interface StreamPayload {
  /**
   * Data sent in the chunk.
   * The amount of data included in each chunk is up to the discretion of the sender, and can be empty.
   * Additionally, the amount of data doesn't need to be fixed and subsequent messages can send more, or less, data.
   * Receivers must not make assumptions about the number of bytes they'll receive in each chunk.
   */
  data: Uint8Array;
  /** Sequence number. This is a counter that starts from 0 and increments by 1 on each chunk sent. */
  seq: Long;
}

/** StateItem represents state key, value, and additional options to save state. */
export interface StateItem {
  /** Required. The state key */
  key: string;
  /** Required. The state data for key */
  value: Uint8Array;
  /**
   * The entity tag which represents the specific version of data.
   * The exact ETag format is defined by the corresponding data store.
   */
  etag:
    | Etag
    | undefined;
  /** The metadata which will be passed to state store component. */
  metadata: { [key: string]: string };
  /** Options for concurrency and consistency to save the state. */
  options: StateOptions | undefined;
}

export interface StateItem_MetadataEntry {
  key: string;
  value: string;
}

/** Etag represents a state item version */
export interface Etag {
  /** value sets the etag value */
  value: string;
}

/** StateOptions configures concurrency and consistency for state operations */
export interface StateOptions {
  concurrency: StateOptions_StateConcurrency;
  consistency: StateOptions_StateConsistency;
}

/** Enum describing the supported concurrency for state. */
export enum StateOptions_StateConcurrency {
  CONCURRENCY_UNSPECIFIED = "CONCURRENCY_UNSPECIFIED",
  CONCURRENCY_FIRST_WRITE = "CONCURRENCY_FIRST_WRITE",
  CONCURRENCY_LAST_WRITE = "CONCURRENCY_LAST_WRITE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function stateOptions_StateConcurrencyFromJSON(object: any): StateOptions_StateConcurrency {
  switch (object) {
    case 0:
    case "CONCURRENCY_UNSPECIFIED":
      return StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED;
    case 1:
    case "CONCURRENCY_FIRST_WRITE":
      return StateOptions_StateConcurrency.CONCURRENCY_FIRST_WRITE;
    case 2:
    case "CONCURRENCY_LAST_WRITE":
      return StateOptions_StateConcurrency.CONCURRENCY_LAST_WRITE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StateOptions_StateConcurrency.UNRECOGNIZED;
  }
}

export function stateOptions_StateConcurrencyToJSON(object: StateOptions_StateConcurrency): string {
  switch (object) {
    case StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED:
      return "CONCURRENCY_UNSPECIFIED";
    case StateOptions_StateConcurrency.CONCURRENCY_FIRST_WRITE:
      return "CONCURRENCY_FIRST_WRITE";
    case StateOptions_StateConcurrency.CONCURRENCY_LAST_WRITE:
      return "CONCURRENCY_LAST_WRITE";
    case StateOptions_StateConcurrency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function stateOptions_StateConcurrencyToNumber(object: StateOptions_StateConcurrency): number {
  switch (object) {
    case StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED:
      return 0;
    case StateOptions_StateConcurrency.CONCURRENCY_FIRST_WRITE:
      return 1;
    case StateOptions_StateConcurrency.CONCURRENCY_LAST_WRITE:
      return 2;
    case StateOptions_StateConcurrency.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Enum describing the supported consistency for state. */
export enum StateOptions_StateConsistency {
  CONSISTENCY_UNSPECIFIED = "CONSISTENCY_UNSPECIFIED",
  CONSISTENCY_EVENTUAL = "CONSISTENCY_EVENTUAL",
  CONSISTENCY_STRONG = "CONSISTENCY_STRONG",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function stateOptions_StateConsistencyFromJSON(object: any): StateOptions_StateConsistency {
  switch (object) {
    case 0:
    case "CONSISTENCY_UNSPECIFIED":
      return StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED;
    case 1:
    case "CONSISTENCY_EVENTUAL":
      return StateOptions_StateConsistency.CONSISTENCY_EVENTUAL;
    case 2:
    case "CONSISTENCY_STRONG":
      return StateOptions_StateConsistency.CONSISTENCY_STRONG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StateOptions_StateConsistency.UNRECOGNIZED;
  }
}

export function stateOptions_StateConsistencyToJSON(object: StateOptions_StateConsistency): string {
  switch (object) {
    case StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED:
      return "CONSISTENCY_UNSPECIFIED";
    case StateOptions_StateConsistency.CONSISTENCY_EVENTUAL:
      return "CONSISTENCY_EVENTUAL";
    case StateOptions_StateConsistency.CONSISTENCY_STRONG:
      return "CONSISTENCY_STRONG";
    case StateOptions_StateConsistency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function stateOptions_StateConsistencyToNumber(object: StateOptions_StateConsistency): number {
  switch (object) {
    case StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED:
      return 0;
    case StateOptions_StateConsistency.CONSISTENCY_EVENTUAL:
      return 1;
    case StateOptions_StateConsistency.CONSISTENCY_STRONG:
      return 2;
    case StateOptions_StateConsistency.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** ConfigurationItem represents all the configuration with its name(key). */
export interface ConfigurationItem {
  /** Required. The value of configuration item. */
  value: string;
  /** Version is response only and cannot be fetched. Store is not expected to keep all versions available */
  version: string;
  /** the metadata which will be passed to/from configuration store component. */
  metadata: { [key: string]: string };
}

export interface ConfigurationItem_MetadataEntry {
  key: string;
  value: string;
}

function createBaseHTTPExtension(): HTTPExtension {
  return { verb: HTTPExtension_Verb.NONE, querystring: "" };
}

export const HTTPExtension = {
  encode(message: HTTPExtension, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.verb !== HTTPExtension_Verb.NONE) {
      writer.uint32(8).int32(hTTPExtension_VerbToNumber(message.verb));
    }
    if (message.querystring !== "") {
      writer.uint32(18).string(message.querystring);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HTTPExtension {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.verb = hTTPExtension_VerbFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.querystring = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<HTTPExtension, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<HTTPExtension | HTTPExtension[]> | Iterable<HTTPExtension | HTTPExtension[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [HTTPExtension.encode(p).finish()];
        }
      } else {
        yield* [HTTPExtension.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, HTTPExtension>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<HTTPExtension> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [HTTPExtension.decode(p)];
        }
      } else {
        yield* [HTTPExtension.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): HTTPExtension {
    return {
      verb: isSet(object.verb) ? hTTPExtension_VerbFromJSON(object.verb) : HTTPExtension_Verb.NONE,
      querystring: isSet(object.querystring) ? globalThis.String(object.querystring) : "",
    };
  },

  toJSON(message: HTTPExtension): unknown {
    const obj: any = {};
    if (message.verb !== HTTPExtension_Verb.NONE) {
      obj.verb = hTTPExtension_VerbToJSON(message.verb);
    }
    if (message.querystring !== "") {
      obj.querystring = message.querystring;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTTPExtension>, I>>(base?: I): HTTPExtension {
    return HTTPExtension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTTPExtension>, I>>(object: I): HTTPExtension {
    const message = createBaseHTTPExtension();
    message.verb = object.verb ?? HTTPExtension_Verb.NONE;
    message.querystring = object.querystring ?? "";
    return message;
  },
};

function createBaseInvokeRequest(): InvokeRequest {
  return { method: "", data: undefined, contentType: "", httpExtension: undefined };
}

export const InvokeRequest = {
  encode(message: InvokeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.data !== undefined) {
      Any.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (message.httpExtension !== undefined) {
      HTTPExtension.encode(message.httpExtension, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Any.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.httpExtension = HTTPExtension.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InvokeRequest, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<InvokeRequest | InvokeRequest[]> | Iterable<InvokeRequest | InvokeRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeRequest.encode(p).finish()];
        }
      } else {
        yield* [InvokeRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InvokeRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InvokeRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeRequest.decode(p)];
        }
      } else {
        yield* [InvokeRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InvokeRequest {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      data: isSet(object.data) ? Any.fromJSON(object.data) : undefined,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      httpExtension: isSet(object.httpExtension) ? HTTPExtension.fromJSON(object.httpExtension) : undefined,
    };
  },

  toJSON(message: InvokeRequest): unknown {
    const obj: any = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.data !== undefined) {
      obj.data = Any.toJSON(message.data);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.httpExtension !== undefined) {
      obj.httpExtension = HTTPExtension.toJSON(message.httpExtension);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeRequest>, I>>(base?: I): InvokeRequest {
    return InvokeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeRequest>, I>>(object: I): InvokeRequest {
    const message = createBaseInvokeRequest();
    message.method = object.method ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Any.fromPartial(object.data) : undefined;
    message.contentType = object.contentType ?? "";
    message.httpExtension = (object.httpExtension !== undefined && object.httpExtension !== null)
      ? HTTPExtension.fromPartial(object.httpExtension)
      : undefined;
    return message;
  },
};

function createBaseInvokeResponse(): InvokeResponse {
  return { data: undefined, contentType: "" };
}

export const InvokeResponse = {
  encode(message: InvokeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined) {
      Any.encode(message.data, writer.uint32(10).fork()).ldelim();
    }
    if (message.contentType !== "") {
      writer.uint32(18).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = Any.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InvokeResponse, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<InvokeResponse | InvokeResponse[]> | Iterable<InvokeResponse | InvokeResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeResponse.encode(p).finish()];
        }
      } else {
        yield* [InvokeResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InvokeResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InvokeResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InvokeResponse.decode(p)];
        }
      } else {
        yield* [InvokeResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InvokeResponse {
    return {
      data: isSet(object.data) ? Any.fromJSON(object.data) : undefined,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: InvokeResponse): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = Any.toJSON(message.data);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeResponse>, I>>(base?: I): InvokeResponse {
    return InvokeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeResponse>, I>>(object: I): InvokeResponse {
    const message = createBaseInvokeResponse();
    message.data = (object.data !== undefined && object.data !== null) ? Any.fromPartial(object.data) : undefined;
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseStreamPayload(): StreamPayload {
  return { data: new Uint8Array(0), seq: Long.UZERO };
}

export const StreamPayload = {
  encode(message: StreamPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (!message.seq.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.seq);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.seq = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<StreamPayload, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<StreamPayload | StreamPayload[]> | Iterable<StreamPayload | StreamPayload[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [StreamPayload.encode(p).finish()];
        }
      } else {
        yield* [StreamPayload.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, StreamPayload>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<StreamPayload> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [StreamPayload.decode(p)];
        }
      } else {
        yield* [StreamPayload.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): StreamPayload {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      seq: isSet(object.seq) ? Long.fromValue(object.seq) : Long.UZERO,
    };
  },

  toJSON(message: StreamPayload): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (!message.seq.equals(Long.UZERO)) {
      obj.seq = (message.seq || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamPayload>, I>>(base?: I): StreamPayload {
    return StreamPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamPayload>, I>>(object: I): StreamPayload {
    const message = createBaseStreamPayload();
    message.data = object.data ?? new Uint8Array(0);
    message.seq = (object.seq !== undefined && object.seq !== null) ? Long.fromValue(object.seq) : Long.UZERO;
    return message;
  },
};

function createBaseStateItem(): StateItem {
  return { key: "", value: new Uint8Array(0), etag: undefined, metadata: {}, options: undefined };
}

export const StateItem = {
  encode(message: StateItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    if (message.etag !== undefined) {
      Etag.encode(message.etag, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      StateItem_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.options !== undefined) {
      StateOptions.encode(message.options, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StateItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = Etag.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = StateItem_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.options = StateOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<StateItem, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<StateItem | StateItem[]> | Iterable<StateItem | StateItem[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [StateItem.encode(p).finish()];
        }
      } else {
        yield* [StateItem.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, StateItem>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<StateItem> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [StateItem.decode(p)];
        }
      } else {
        yield* [StateItem.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): StateItem {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      etag: isSet(object.etag) ? Etag.fromJSON(object.etag) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      options: isSet(object.options) ? StateOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: StateItem): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.etag !== undefined) {
      obj.etag = Etag.toJSON(message.etag);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.options !== undefined) {
      obj.options = StateOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StateItem>, I>>(base?: I): StateItem {
    return StateItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateItem>, I>>(object: I): StateItem {
    const message = createBaseStateItem();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    message.etag = (object.etag !== undefined && object.etag !== null) ? Etag.fromPartial(object.etag) : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.options = (object.options !== undefined && object.options !== null)
      ? StateOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseStateItem_MetadataEntry(): StateItem_MetadataEntry {
  return { key: "", value: "" };
}

export const StateItem_MetadataEntry = {
  encode(message: StateItem_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StateItem_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateItem_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<StateItem_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<StateItem_MetadataEntry | StateItem_MetadataEntry[]>
      | Iterable<StateItem_MetadataEntry | StateItem_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [StateItem_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [StateItem_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, StateItem_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<StateItem_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [StateItem_MetadataEntry.decode(p)];
        }
      } else {
        yield* [StateItem_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): StateItem_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StateItem_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StateItem_MetadataEntry>, I>>(base?: I): StateItem_MetadataEntry {
    return StateItem_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateItem_MetadataEntry>, I>>(object: I): StateItem_MetadataEntry {
    const message = createBaseStateItem_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEtag(): Etag {
  return { value: "" };
}

export const Etag = {
  encode(message: Etag, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Etag {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEtag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Etag, Uint8Array>
  async *encodeTransform(source: AsyncIterable<Etag | Etag[]> | Iterable<Etag | Etag[]>): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Etag.encode(p).finish()];
        }
      } else {
        yield* [Etag.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Etag>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Etag> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Etag.decode(p)];
        }
      } else {
        yield* [Etag.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Etag {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: Etag): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Etag>, I>>(base?: I): Etag {
    return Etag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Etag>, I>>(object: I): Etag {
    const message = createBaseEtag();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStateOptions(): StateOptions {
  return {
    concurrency: StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED,
    consistency: StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED,
  };
}

export const StateOptions = {
  encode(message: StateOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.concurrency !== StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED) {
      writer.uint32(8).int32(stateOptions_StateConcurrencyToNumber(message.concurrency));
    }
    if (message.consistency !== StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED) {
      writer.uint32(16).int32(stateOptions_StateConsistencyToNumber(message.consistency));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StateOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.concurrency = stateOptions_StateConcurrencyFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.consistency = stateOptions_StateConsistencyFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<StateOptions, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<StateOptions | StateOptions[]> | Iterable<StateOptions | StateOptions[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [StateOptions.encode(p).finish()];
        }
      } else {
        yield* [StateOptions.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, StateOptions>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<StateOptions> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [StateOptions.decode(p)];
        }
      } else {
        yield* [StateOptions.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): StateOptions {
    return {
      concurrency: isSet(object.concurrency)
        ? stateOptions_StateConcurrencyFromJSON(object.concurrency)
        : StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED,
      consistency: isSet(object.consistency)
        ? stateOptions_StateConsistencyFromJSON(object.consistency)
        : StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED,
    };
  },

  toJSON(message: StateOptions): unknown {
    const obj: any = {};
    if (message.concurrency !== StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED) {
      obj.concurrency = stateOptions_StateConcurrencyToJSON(message.concurrency);
    }
    if (message.consistency !== StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED) {
      obj.consistency = stateOptions_StateConsistencyToJSON(message.consistency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StateOptions>, I>>(base?: I): StateOptions {
    return StateOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateOptions>, I>>(object: I): StateOptions {
    const message = createBaseStateOptions();
    message.concurrency = object.concurrency ?? StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED;
    message.consistency = object.consistency ?? StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED;
    return message;
  },
};

function createBaseConfigurationItem(): ConfigurationItem {
  return { value: "", version: "", metadata: {} };
}

export const ConfigurationItem = {
  encode(message: ConfigurationItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ConfigurationItem_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfigurationItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigurationItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ConfigurationItem_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ConfigurationItem, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<ConfigurationItem | ConfigurationItem[]> | Iterable<ConfigurationItem | ConfigurationItem[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ConfigurationItem.encode(p).finish()];
        }
      } else {
        yield* [ConfigurationItem.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ConfigurationItem>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ConfigurationItem> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ConfigurationItem.decode(p)];
        }
      } else {
        yield* [ConfigurationItem.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ConfigurationItem {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ConfigurationItem): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigurationItem>, I>>(base?: I): ConfigurationItem {
    return ConfigurationItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigurationItem>, I>>(object: I): ConfigurationItem {
    const message = createBaseConfigurationItem();
    message.value = object.value ?? "";
    message.version = object.version ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseConfigurationItem_MetadataEntry(): ConfigurationItem_MetadataEntry {
  return { key: "", value: "" };
}

export const ConfigurationItem_MetadataEntry = {
  encode(message: ConfigurationItem_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfigurationItem_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigurationItem_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ConfigurationItem_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ConfigurationItem_MetadataEntry | ConfigurationItem_MetadataEntry[]>
      | Iterable<ConfigurationItem_MetadataEntry | ConfigurationItem_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ConfigurationItem_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [ConfigurationItem_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ConfigurationItem_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ConfigurationItem_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ConfigurationItem_MetadataEntry.decode(p)];
        }
      } else {
        yield* [ConfigurationItem_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ConfigurationItem_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConfigurationItem_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigurationItem_MetadataEntry>, I>>(base?: I): ConfigurationItem_MetadataEntry {
    return ConfigurationItem_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigurationItem_MetadataEntry>, I>>(
    object: I,
  ): ConfigurationItem_MetadataEntry {
    const message = createBaseConfigurationItem_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
