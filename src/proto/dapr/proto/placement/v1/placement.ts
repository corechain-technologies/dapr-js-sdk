// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.19.1
// source: dapr/proto/placement/v1/placement.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  handleBidiStreamingCall,
  makeGenericClientConstructor,
  Metadata,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "dapr.proto.placement.v1";

export interface PlacementOrder {
  tables: PlacementTables | undefined;
  operation: string;
}

export interface PlacementTables {
  entries: { [key: string]: PlacementTable };
  version: string;
}

export interface PlacementTables_EntriesEntry {
  key: string;
  value: PlacementTable | undefined;
}

export interface PlacementTable {
  hosts: Map<Long, string>;
  sortedSet: Long[];
  loadMap: { [key: string]: Host };
  totalLoad: Long;
}

export interface PlacementTable_HostsEntry {
  key: Long;
  value: string;
}

export interface PlacementTable_LoadMapEntry {
  key: string;
  value: Host | undefined;
}

export interface Host {
  name: string;
  port: Long;
  load: Long;
  entities: string[];
  id: string;
  pod: string;
  /** Version of the Actor APIs supported by the Dapr runtime */
  apiLevel: number;
}

function createBasePlacementOrder(): PlacementOrder {
  return { tables: undefined, operation: "" };
}

export const PlacementOrder = {
  encode(message: PlacementOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tables !== undefined) {
      PlacementTables.encode(message.tables, writer.uint32(10).fork()).ldelim();
    }
    if (message.operation !== "") {
      writer.uint32(18).string(message.operation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlacementOrder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlacementOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tables = PlacementTables.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PlacementOrder, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<PlacementOrder | PlacementOrder[]> | Iterable<PlacementOrder | PlacementOrder[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementOrder.encode(p).finish()];
        }
      } else {
        yield* [PlacementOrder.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PlacementOrder>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PlacementOrder> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementOrder.decode(p)];
        }
      } else {
        yield* [PlacementOrder.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PlacementOrder {
    return {
      tables: isSet(object.tables) ? PlacementTables.fromJSON(object.tables) : undefined,
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
    };
  },

  toJSON(message: PlacementOrder): unknown {
    const obj: any = {};
    if (message.tables !== undefined) {
      obj.tables = PlacementTables.toJSON(message.tables);
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlacementOrder>, I>>(base?: I): PlacementOrder {
    return PlacementOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlacementOrder>, I>>(object: I): PlacementOrder {
    const message = createBasePlacementOrder();
    message.tables = (object.tables !== undefined && object.tables !== null)
      ? PlacementTables.fromPartial(object.tables)
      : undefined;
    message.operation = object.operation ?? "";
    return message;
  },
};

function createBasePlacementTables(): PlacementTables {
  return { entries: {}, version: "" };
}

export const PlacementTables = {
  encode(message: PlacementTables, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.entries).forEach(([key, value]) => {
      PlacementTables_EntriesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlacementTables {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlacementTables();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = PlacementTables_EntriesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.entries[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PlacementTables, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<PlacementTables | PlacementTables[]> | Iterable<PlacementTables | PlacementTables[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementTables.encode(p).finish()];
        }
      } else {
        yield* [PlacementTables.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PlacementTables>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PlacementTables> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementTables.decode(p)];
        }
      } else {
        yield* [PlacementTables.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PlacementTables {
    return {
      entries: isObject(object.entries)
        ? Object.entries(object.entries).reduce<{ [key: string]: PlacementTable }>((acc, [key, value]) => {
          acc[key] = PlacementTable.fromJSON(value);
          return acc;
        }, {})
        : {},
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: PlacementTables): unknown {
    const obj: any = {};
    if (message.entries) {
      const entries = Object.entries(message.entries);
      if (entries.length > 0) {
        obj.entries = {};
        entries.forEach(([k, v]) => {
          obj.entries[k] = PlacementTable.toJSON(v);
        });
      }
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlacementTables>, I>>(base?: I): PlacementTables {
    return PlacementTables.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlacementTables>, I>>(object: I): PlacementTables {
    const message = createBasePlacementTables();
    message.entries = Object.entries(object.entries ?? {}).reduce<{ [key: string]: PlacementTable }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = PlacementTable.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.version = object.version ?? "";
    return message;
  },
};

function createBasePlacementTables_EntriesEntry(): PlacementTables_EntriesEntry {
  return { key: "", value: undefined };
}

export const PlacementTables_EntriesEntry = {
  encode(message: PlacementTables_EntriesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      PlacementTable.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlacementTables_EntriesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlacementTables_EntriesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = PlacementTable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PlacementTables_EntriesEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<PlacementTables_EntriesEntry | PlacementTables_EntriesEntry[]>
      | Iterable<PlacementTables_EntriesEntry | PlacementTables_EntriesEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementTables_EntriesEntry.encode(p).finish()];
        }
      } else {
        yield* [PlacementTables_EntriesEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PlacementTables_EntriesEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PlacementTables_EntriesEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementTables_EntriesEntry.decode(p)];
        }
      } else {
        yield* [PlacementTables_EntriesEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PlacementTables_EntriesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? PlacementTable.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PlacementTables_EntriesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = PlacementTable.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlacementTables_EntriesEntry>, I>>(base?: I): PlacementTables_EntriesEntry {
    return PlacementTables_EntriesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlacementTables_EntriesEntry>, I>>(object: I): PlacementTables_EntriesEntry {
    const message = createBasePlacementTables_EntriesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? PlacementTable.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePlacementTable(): PlacementTable {
  return { hosts: new Map(), sortedSet: [], loadMap: {}, totalLoad: Long.ZERO };
}

export const PlacementTable = {
  encode(message: PlacementTable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    message.hosts.forEach((value, key) => {
      PlacementTable_HostsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    writer.uint32(18).fork();
    for (const v of message.sortedSet) {
      writer.uint64(v);
    }
    writer.ldelim();
    Object.entries(message.loadMap).forEach(([key, value]) => {
      PlacementTable_LoadMapEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (!message.totalLoad.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalLoad);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlacementTable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlacementTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = PlacementTable_HostsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.hosts.set(entry1.key, entry1.value);
          }
          continue;
        case 2:
          if (tag === 16) {
            message.sortedSet.push(reader.uint64() as Long);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.sortedSet.push(reader.uint64() as Long);
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = PlacementTable_LoadMapEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.loadMap[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalLoad = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PlacementTable, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<PlacementTable | PlacementTable[]> | Iterable<PlacementTable | PlacementTable[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementTable.encode(p).finish()];
        }
      } else {
        yield* [PlacementTable.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PlacementTable>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PlacementTable> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementTable.decode(p)];
        }
      } else {
        yield* [PlacementTable.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PlacementTable {
    return {
      hosts: isObject(object.hosts)
        ? Object.entries(object.hosts).reduce<Map<Long, string>>((acc, [key, value]) => {
          acc.set(Long.fromValue(key), String(value));
          return acc;
        }, new Map())
        : new Map(),
      sortedSet: globalThis.Array.isArray(object?.sortedSet) ? object.sortedSet.map((e: any) => Long.fromValue(e)) : [],
      loadMap: isObject(object.loadMap)
        ? Object.entries(object.loadMap).reduce<{ [key: string]: Host }>((acc, [key, value]) => {
          acc[key] = Host.fromJSON(value);
          return acc;
        }, {})
        : {},
      totalLoad: isSet(object.totalLoad) ? Long.fromValue(object.totalLoad) : Long.ZERO,
    };
  },

  toJSON(message: PlacementTable): unknown {
    const obj: any = {};
    if (message.hosts?.size) {
      obj.hosts = {};
      message.hosts.forEach((v, k) => {
        obj.hosts[longToNumber(k)] = v;
      });
    }
    if (message.sortedSet?.length) {
      obj.sortedSet = message.sortedSet.map((e) => (e || Long.UZERO).toString());
    }
    if (message.loadMap) {
      const entries = Object.entries(message.loadMap);
      if (entries.length > 0) {
        obj.loadMap = {};
        entries.forEach(([k, v]) => {
          obj.loadMap[k] = Host.toJSON(v);
        });
      }
    }
    if (!message.totalLoad.equals(Long.ZERO)) {
      obj.totalLoad = (message.totalLoad || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlacementTable>, I>>(base?: I): PlacementTable {
    return PlacementTable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlacementTable>, I>>(object: I): PlacementTable {
    const message = createBasePlacementTable();
    message.hosts = (() => {
      const m = new Map();
      (object.hosts as Map<Long, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    message.sortedSet = object.sortedSet?.map((e) => Long.fromValue(e)) || [];
    message.loadMap = Object.entries(object.loadMap ?? {}).reduce<{ [key: string]: Host }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Host.fromPartial(value);
      }
      return acc;
    }, {});
    message.totalLoad = (object.totalLoad !== undefined && object.totalLoad !== null)
      ? Long.fromValue(object.totalLoad)
      : Long.ZERO;
    return message;
  },
};

function createBasePlacementTable_HostsEntry(): PlacementTable_HostsEntry {
  return { key: Long.UZERO, value: "" };
}

export const PlacementTable_HostsEntry = {
  encode(message: PlacementTable_HostsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.key.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlacementTable_HostsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlacementTable_HostsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PlacementTable_HostsEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<PlacementTable_HostsEntry | PlacementTable_HostsEntry[]>
      | Iterable<PlacementTable_HostsEntry | PlacementTable_HostsEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementTable_HostsEntry.encode(p).finish()];
        }
      } else {
        yield* [PlacementTable_HostsEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PlacementTable_HostsEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PlacementTable_HostsEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementTable_HostsEntry.decode(p)];
        }
      } else {
        yield* [PlacementTable_HostsEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PlacementTable_HostsEntry {
    return {
      key: isSet(object.key) ? Long.fromValue(object.key) : Long.UZERO,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PlacementTable_HostsEntry): unknown {
    const obj: any = {};
    if (!message.key.equals(Long.UZERO)) {
      obj.key = (message.key || Long.UZERO).toString();
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlacementTable_HostsEntry>, I>>(base?: I): PlacementTable_HostsEntry {
    return PlacementTable_HostsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlacementTable_HostsEntry>, I>>(object: I): PlacementTable_HostsEntry {
    const message = createBasePlacementTable_HostsEntry();
    message.key = (object.key !== undefined && object.key !== null) ? Long.fromValue(object.key) : Long.UZERO;
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePlacementTable_LoadMapEntry(): PlacementTable_LoadMapEntry {
  return { key: "", value: undefined };
}

export const PlacementTable_LoadMapEntry = {
  encode(message: PlacementTable_LoadMapEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Host.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlacementTable_LoadMapEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlacementTable_LoadMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Host.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<PlacementTable_LoadMapEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<PlacementTable_LoadMapEntry | PlacementTable_LoadMapEntry[]>
      | Iterable<PlacementTable_LoadMapEntry | PlacementTable_LoadMapEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementTable_LoadMapEntry.encode(p).finish()];
        }
      } else {
        yield* [PlacementTable_LoadMapEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, PlacementTable_LoadMapEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<PlacementTable_LoadMapEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [PlacementTable_LoadMapEntry.decode(p)];
        }
      } else {
        yield* [PlacementTable_LoadMapEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): PlacementTable_LoadMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Host.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PlacementTable_LoadMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Host.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlacementTable_LoadMapEntry>, I>>(base?: I): PlacementTable_LoadMapEntry {
    return PlacementTable_LoadMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlacementTable_LoadMapEntry>, I>>(object: I): PlacementTable_LoadMapEntry {
    const message = createBasePlacementTable_LoadMapEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Host.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseHost(): Host {
  return { name: "", port: Long.ZERO, load: Long.ZERO, entities: [], id: "", pod: "", apiLevel: 0 };
}

export const Host = {
  encode(message: Host, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.port.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.port);
    }
    if (!message.load.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.load);
    }
    for (const v of message.entities) {
      writer.uint32(34).string(v!);
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    if (message.pod !== "") {
      writer.uint32(50).string(message.pod);
    }
    if (message.apiLevel !== 0) {
      writer.uint32(56).uint32(message.apiLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Host {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.load = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.entities.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pod = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.apiLevel = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Host, Uint8Array>
  async *encodeTransform(source: AsyncIterable<Host | Host[]> | Iterable<Host | Host[]>): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Host.encode(p).finish()];
        }
      } else {
        yield* [Host.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Host>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Host> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Host.decode(p)];
        }
      } else {
        yield* [Host.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Host {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      port: isSet(object.port) ? Long.fromValue(object.port) : Long.ZERO,
      load: isSet(object.load) ? Long.fromValue(object.load) : Long.ZERO,
      entities: globalThis.Array.isArray(object?.entities) ? object.entities.map((e: any) => globalThis.String(e)) : [],
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pod: isSet(object.pod) ? globalThis.String(object.pod) : "",
      apiLevel: isSet(object.apiLevel) ? globalThis.Number(object.apiLevel) : 0,
    };
  },

  toJSON(message: Host): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.port.equals(Long.ZERO)) {
      obj.port = (message.port || Long.ZERO).toString();
    }
    if (!message.load.equals(Long.ZERO)) {
      obj.load = (message.load || Long.ZERO).toString();
    }
    if (message.entities?.length) {
      obj.entities = message.entities;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pod !== "") {
      obj.pod = message.pod;
    }
    if (message.apiLevel !== 0) {
      obj.apiLevel = Math.round(message.apiLevel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Host>, I>>(base?: I): Host {
    return Host.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Host>, I>>(object: I): Host {
    const message = createBaseHost();
    message.name = object.name ?? "";
    message.port = (object.port !== undefined && object.port !== null) ? Long.fromValue(object.port) : Long.ZERO;
    message.load = (object.load !== undefined && object.load !== null) ? Long.fromValue(object.load) : Long.ZERO;
    message.entities = object.entities?.map((e) => e) || [];
    message.id = object.id ?? "";
    message.pod = object.pod ?? "";
    message.apiLevel = object.apiLevel ?? 0;
    return message;
  },
};

/** Placement service is used to report Dapr runtime host status. */
export type PlacementService = typeof PlacementService;
export const PlacementService = {
  /** Reports Dapr actor status and retrieves actor placement table. */
  reportDaprStatus: {
    path: "/dapr.proto.placement.v1.Placement/ReportDaprStatus",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: Host) => Buffer.from(Host.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Host.decode(value),
    responseSerialize: (value: PlacementOrder) => Buffer.from(PlacementOrder.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PlacementOrder.decode(value),
  },
} as const;

export interface PlacementServer extends UntypedServiceImplementation {
  /** Reports Dapr actor status and retrieves actor placement table. */
  reportDaprStatus: handleBidiStreamingCall<Host, PlacementOrder>;
}

export interface PlacementClient extends Client {
  /** Reports Dapr actor status and retrieves actor placement table. */
  reportDaprStatus(): ClientDuplexStream<Host, PlacementOrder>;
  reportDaprStatus(options: Partial<CallOptions>): ClientDuplexStream<Host, PlacementOrder>;
  reportDaprStatus(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<Host, PlacementOrder>;
}

export const PlacementClient = makeGenericClientConstructor(
  PlacementService,
  "dapr.proto.placement.v1.Placement",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PlacementClient;
  service: typeof PlacementService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
