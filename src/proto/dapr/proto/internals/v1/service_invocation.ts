// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.19.1
// source: dapr/proto/internals/v1/service_invocation.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { InvokeRequest, InvokeResponse, StreamPayload } from "../../common/v1/common";
import { APIVersion, aPIVersionFromJSON, aPIVersionToJSON, aPIVersionToNumber } from "./apiversion";
import { Status } from "./status";

export const protobufPackage = "dapr.proto.internals.v1";

/** Actor represents actor using actor_type and actor_id */
export interface Actor {
  /** Required. The type of actor. */
  actorType: string;
  /** Required. The ID of actor type (actor_type) */
  actorId: string;
}

/**
 * InternalInvokeRequest is the message to transfer caller's data to callee
 * for service invocation. This includes callee's app id and caller's request data.
 */
export interface InternalInvokeRequest {
  /** Required. The version of Dapr runtime API. */
  ver: APIVersion;
  /** Required. metadata holds caller's HTTP headers or gRPC metadata. */
  metadata: { [key: string]: ListStringValue };
  /** Required. message including caller's invocation request. */
  message:
    | InvokeRequest
    | undefined;
  /**
   * Actor type and id. This field is used only for
   * actor service invocation.
   */
  actor: Actor | undefined;
}

export interface InternalInvokeRequest_MetadataEntry {
  key: string;
  value: ListStringValue | undefined;
}

/**
 * InternalInvokeResponse is the message to transfer callee's response to caller
 * for service invocation.
 */
export interface InternalInvokeResponse {
  /** Required. HTTP/gRPC status. */
  status:
    | Status
    | undefined;
  /** Required. The app callback response headers. */
  headers: { [key: string]: ListStringValue };
  /**
   * App callback response trailers.
   * This will be used only for gRPC app callback
   */
  trailers: { [key: string]: ListStringValue };
  /** Callee's invocation response message. */
  message: InvokeResponse | undefined;
}

export interface InternalInvokeResponse_HeadersEntry {
  key: string;
  value: ListStringValue | undefined;
}

export interface InternalInvokeResponse_TrailersEntry {
  key: string;
  value: ListStringValue | undefined;
}

/** InternalInvokeRequestStream is a variant of InternalInvokeRequest used in streaming RPCs. */
export interface InternalInvokeRequestStream {
  /**
   * Request details.
   * This does not contain any data in message.data.
   */
  request:
    | InternalInvokeRequest
    | undefined;
  /** Chunk of data. */
  payload: StreamPayload | undefined;
}

/** InternalInvokeResponseStream is a variant of InternalInvokeResponse used in streaming RPCs. */
export interface InternalInvokeResponseStream {
  /**
   * Response details.
   * This does not contain any data in message.data.
   */
  response:
    | InternalInvokeResponse
    | undefined;
  /** Chunk of data. */
  payload: StreamPayload | undefined;
}

/** ListStringValue represents string value array */
export interface ListStringValue {
  /** The array of string. */
  values: string[];
}

function createBaseActor(): Actor {
  return { actorType: "", actorId: "" };
}

export const Actor = {
  encode(message: Actor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actorType !== "") {
      writer.uint32(10).string(message.actorType);
    }
    if (message.actorId !== "") {
      writer.uint32(18).string(message.actorId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Actor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actorType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actorId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<Actor, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<Actor | Actor[]> | Iterable<Actor | Actor[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Actor.encode(p).finish()];
        }
      } else {
        yield* [Actor.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, Actor>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<Actor> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [Actor.decode(p)];
        }
      } else {
        yield* [Actor.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): Actor {
    return {
      actorType: isSet(object.actorType) ? globalThis.String(object.actorType) : "",
      actorId: isSet(object.actorId) ? globalThis.String(object.actorId) : "",
    };
  },

  toJSON(message: Actor): unknown {
    const obj: any = {};
    if (message.actorType !== "") {
      obj.actorType = message.actorType;
    }
    if (message.actorId !== "") {
      obj.actorId = message.actorId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Actor>, I>>(base?: I): Actor {
    return Actor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Actor>, I>>(object: I): Actor {
    const message = createBaseActor();
    message.actorType = object.actorType ?? "";
    message.actorId = object.actorId ?? "";
    return message;
  },
};

function createBaseInternalInvokeRequest(): InternalInvokeRequest {
  return { ver: APIVersion.APIVERSION_UNSPECIFIED, metadata: {}, message: undefined, actor: undefined };
}

export const InternalInvokeRequest = {
  encode(message: InternalInvokeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ver !== APIVersion.APIVERSION_UNSPECIFIED) {
      writer.uint32(8).int32(aPIVersionToNumber(message.ver));
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      InternalInvokeRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.message !== undefined) {
      InvokeRequest.encode(message.message, writer.uint32(26).fork()).ldelim();
    }
    if (message.actor !== undefined) {
      Actor.encode(message.actor, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalInvokeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalInvokeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ver = aPIVersionFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = InternalInvokeRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = InvokeRequest.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.actor = Actor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InternalInvokeRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InternalInvokeRequest | InternalInvokeRequest[]>
      | Iterable<InternalInvokeRequest | InternalInvokeRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeRequest.encode(p).finish()];
        }
      } else {
        yield* [InternalInvokeRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InternalInvokeRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InternalInvokeRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeRequest.decode(p)];
        }
      } else {
        yield* [InternalInvokeRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InternalInvokeRequest {
    return {
      ver: isSet(object.ver) ? aPIVersionFromJSON(object.ver) : APIVersion.APIVERSION_UNSPECIFIED,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: ListStringValue }>((acc, [key, value]) => {
          acc[key] = ListStringValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      message: isSet(object.message) ? InvokeRequest.fromJSON(object.message) : undefined,
      actor: isSet(object.actor) ? Actor.fromJSON(object.actor) : undefined,
    };
  },

  toJSON(message: InternalInvokeRequest): unknown {
    const obj: any = {};
    if (message.ver !== APIVersion.APIVERSION_UNSPECIFIED) {
      obj.ver = aPIVersionToJSON(message.ver);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = ListStringValue.toJSON(v);
        });
      }
    }
    if (message.message !== undefined) {
      obj.message = InvokeRequest.toJSON(message.message);
    }
    if (message.actor !== undefined) {
      obj.actor = Actor.toJSON(message.actor);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalInvokeRequest>, I>>(base?: I): InternalInvokeRequest {
    return InternalInvokeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalInvokeRequest>, I>>(object: I): InternalInvokeRequest {
    const message = createBaseInternalInvokeRequest();
    message.ver = object.ver ?? APIVersion.APIVERSION_UNSPECIFIED;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: ListStringValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ListStringValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.message = (object.message !== undefined && object.message !== null)
      ? InvokeRequest.fromPartial(object.message)
      : undefined;
    message.actor = (object.actor !== undefined && object.actor !== null) ? Actor.fromPartial(object.actor) : undefined;
    return message;
  },
};

function createBaseInternalInvokeRequest_MetadataEntry(): InternalInvokeRequest_MetadataEntry {
  return { key: "", value: undefined };
}

export const InternalInvokeRequest_MetadataEntry = {
  encode(message: InternalInvokeRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListStringValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalInvokeRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalInvokeRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListStringValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InternalInvokeRequest_MetadataEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InternalInvokeRequest_MetadataEntry | InternalInvokeRequest_MetadataEntry[]>
      | Iterable<InternalInvokeRequest_MetadataEntry | InternalInvokeRequest_MetadataEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeRequest_MetadataEntry.encode(p).finish()];
        }
      } else {
        yield* [InternalInvokeRequest_MetadataEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InternalInvokeRequest_MetadataEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InternalInvokeRequest_MetadataEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeRequest_MetadataEntry.decode(p)];
        }
      } else {
        yield* [InternalInvokeRequest_MetadataEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InternalInvokeRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ListStringValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: InternalInvokeRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ListStringValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalInvokeRequest_MetadataEntry>, I>>(
    base?: I,
  ): InternalInvokeRequest_MetadataEntry {
    return InternalInvokeRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalInvokeRequest_MetadataEntry>, I>>(
    object: I,
  ): InternalInvokeRequest_MetadataEntry {
    const message = createBaseInternalInvokeRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ListStringValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseInternalInvokeResponse(): InternalInvokeResponse {
  return { status: undefined, headers: {}, trailers: {}, message: undefined };
}

export const InternalInvokeResponse = {
  encode(message: InternalInvokeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      InternalInvokeResponse_HeadersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.trailers).forEach(([key, value]) => {
      InternalInvokeResponse_TrailersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.message !== undefined) {
      InvokeResponse.encode(message.message, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalInvokeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalInvokeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = InternalInvokeResponse_HeadersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.headers[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = InternalInvokeResponse_TrailersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.trailers[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = InvokeResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InternalInvokeResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InternalInvokeResponse | InternalInvokeResponse[]>
      | Iterable<InternalInvokeResponse | InternalInvokeResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeResponse.encode(p).finish()];
        }
      } else {
        yield* [InternalInvokeResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InternalInvokeResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InternalInvokeResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeResponse.decode(p)];
        }
      } else {
        yield* [InternalInvokeResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InternalInvokeResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: ListStringValue }>((acc, [key, value]) => {
          acc[key] = ListStringValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      trailers: isObject(object.trailers)
        ? Object.entries(object.trailers).reduce<{ [key: string]: ListStringValue }>((acc, [key, value]) => {
          acc[key] = ListStringValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      message: isSet(object.message) ? InvokeResponse.fromJSON(object.message) : undefined,
    };
  },

  toJSON(message: InternalInvokeResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = ListStringValue.toJSON(v);
        });
      }
    }
    if (message.trailers) {
      const entries = Object.entries(message.trailers);
      if (entries.length > 0) {
        obj.trailers = {};
        entries.forEach(([k, v]) => {
          obj.trailers[k] = ListStringValue.toJSON(v);
        });
      }
    }
    if (message.message !== undefined) {
      obj.message = InvokeResponse.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalInvokeResponse>, I>>(base?: I): InternalInvokeResponse {
    return InternalInvokeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalInvokeResponse>, I>>(object: I): InternalInvokeResponse {
    const message = createBaseInternalInvokeResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: ListStringValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ListStringValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.trailers = Object.entries(object.trailers ?? {}).reduce<{ [key: string]: ListStringValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ListStringValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.message = (object.message !== undefined && object.message !== null)
      ? InvokeResponse.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseInternalInvokeResponse_HeadersEntry(): InternalInvokeResponse_HeadersEntry {
  return { key: "", value: undefined };
}

export const InternalInvokeResponse_HeadersEntry = {
  encode(message: InternalInvokeResponse_HeadersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListStringValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalInvokeResponse_HeadersEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalInvokeResponse_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListStringValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InternalInvokeResponse_HeadersEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InternalInvokeResponse_HeadersEntry | InternalInvokeResponse_HeadersEntry[]>
      | Iterable<InternalInvokeResponse_HeadersEntry | InternalInvokeResponse_HeadersEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeResponse_HeadersEntry.encode(p).finish()];
        }
      } else {
        yield* [InternalInvokeResponse_HeadersEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InternalInvokeResponse_HeadersEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InternalInvokeResponse_HeadersEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeResponse_HeadersEntry.decode(p)];
        }
      } else {
        yield* [InternalInvokeResponse_HeadersEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InternalInvokeResponse_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ListStringValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: InternalInvokeResponse_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ListStringValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalInvokeResponse_HeadersEntry>, I>>(
    base?: I,
  ): InternalInvokeResponse_HeadersEntry {
    return InternalInvokeResponse_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalInvokeResponse_HeadersEntry>, I>>(
    object: I,
  ): InternalInvokeResponse_HeadersEntry {
    const message = createBaseInternalInvokeResponse_HeadersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ListStringValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseInternalInvokeResponse_TrailersEntry(): InternalInvokeResponse_TrailersEntry {
  return { key: "", value: undefined };
}

export const InternalInvokeResponse_TrailersEntry = {
  encode(message: InternalInvokeResponse_TrailersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListStringValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalInvokeResponse_TrailersEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalInvokeResponse_TrailersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListStringValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InternalInvokeResponse_TrailersEntry, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InternalInvokeResponse_TrailersEntry | InternalInvokeResponse_TrailersEntry[]>
      | Iterable<InternalInvokeResponse_TrailersEntry | InternalInvokeResponse_TrailersEntry[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeResponse_TrailersEntry.encode(p).finish()];
        }
      } else {
        yield* [InternalInvokeResponse_TrailersEntry.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InternalInvokeResponse_TrailersEntry>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InternalInvokeResponse_TrailersEntry> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeResponse_TrailersEntry.decode(p)];
        }
      } else {
        yield* [InternalInvokeResponse_TrailersEntry.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InternalInvokeResponse_TrailersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ListStringValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: InternalInvokeResponse_TrailersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ListStringValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalInvokeResponse_TrailersEntry>, I>>(
    base?: I,
  ): InternalInvokeResponse_TrailersEntry {
    return InternalInvokeResponse_TrailersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalInvokeResponse_TrailersEntry>, I>>(
    object: I,
  ): InternalInvokeResponse_TrailersEntry {
    const message = createBaseInternalInvokeResponse_TrailersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ListStringValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseInternalInvokeRequestStream(): InternalInvokeRequestStream {
  return { request: undefined, payload: undefined };
}

export const InternalInvokeRequestStream = {
  encode(message: InternalInvokeRequestStream, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.request !== undefined) {
      InternalInvokeRequest.encode(message.request, writer.uint32(10).fork()).ldelim();
    }
    if (message.payload !== undefined) {
      StreamPayload.encode(message.payload, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalInvokeRequestStream {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalInvokeRequestStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.request = InternalInvokeRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = StreamPayload.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InternalInvokeRequestStream, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InternalInvokeRequestStream | InternalInvokeRequestStream[]>
      | Iterable<InternalInvokeRequestStream | InternalInvokeRequestStream[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeRequestStream.encode(p).finish()];
        }
      } else {
        yield* [InternalInvokeRequestStream.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InternalInvokeRequestStream>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InternalInvokeRequestStream> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeRequestStream.decode(p)];
        }
      } else {
        yield* [InternalInvokeRequestStream.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InternalInvokeRequestStream {
    return {
      request: isSet(object.request) ? InternalInvokeRequest.fromJSON(object.request) : undefined,
      payload: isSet(object.payload) ? StreamPayload.fromJSON(object.payload) : undefined,
    };
  },

  toJSON(message: InternalInvokeRequestStream): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = InternalInvokeRequest.toJSON(message.request);
    }
    if (message.payload !== undefined) {
      obj.payload = StreamPayload.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalInvokeRequestStream>, I>>(base?: I): InternalInvokeRequestStream {
    return InternalInvokeRequestStream.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalInvokeRequestStream>, I>>(object: I): InternalInvokeRequestStream {
    const message = createBaseInternalInvokeRequestStream();
    message.request = (object.request !== undefined && object.request !== null)
      ? InternalInvokeRequest.fromPartial(object.request)
      : undefined;
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? StreamPayload.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseInternalInvokeResponseStream(): InternalInvokeResponseStream {
  return { response: undefined, payload: undefined };
}

export const InternalInvokeResponseStream = {
  encode(message: InternalInvokeResponseStream, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      InternalInvokeResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    if (message.payload !== undefined) {
      StreamPayload.encode(message.payload, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalInvokeResponseStream {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalInvokeResponseStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = InternalInvokeResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = StreamPayload.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<InternalInvokeResponseStream, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<InternalInvokeResponseStream | InternalInvokeResponseStream[]>
      | Iterable<InternalInvokeResponseStream | InternalInvokeResponseStream[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeResponseStream.encode(p).finish()];
        }
      } else {
        yield* [InternalInvokeResponseStream.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, InternalInvokeResponseStream>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<InternalInvokeResponseStream> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [InternalInvokeResponseStream.decode(p)];
        }
      } else {
        yield* [InternalInvokeResponseStream.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): InternalInvokeResponseStream {
    return {
      response: isSet(object.response) ? InternalInvokeResponse.fromJSON(object.response) : undefined,
      payload: isSet(object.payload) ? StreamPayload.fromJSON(object.payload) : undefined,
    };
  },

  toJSON(message: InternalInvokeResponseStream): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = InternalInvokeResponse.toJSON(message.response);
    }
    if (message.payload !== undefined) {
      obj.payload = StreamPayload.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalInvokeResponseStream>, I>>(base?: I): InternalInvokeResponseStream {
    return InternalInvokeResponseStream.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalInvokeResponseStream>, I>>(object: I): InternalInvokeResponseStream {
    const message = createBaseInternalInvokeResponseStream();
    message.response = (object.response !== undefined && object.response !== null)
      ? InternalInvokeResponse.fromPartial(object.response)
      : undefined;
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? StreamPayload.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseListStringValue(): ListStringValue {
  return { values: [] };
}

export const ListStringValue = {
  encode(message: ListStringValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStringValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStringValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListStringValue, Uint8Array>
  async *encodeTransform(
    source: AsyncIterable<ListStringValue | ListStringValue[]> | Iterable<ListStringValue | ListStringValue[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListStringValue.encode(p).finish()];
        }
      } else {
        yield* [ListStringValue.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListStringValue>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListStringValue> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListStringValue.decode(p)];
        }
      } else {
        yield* [ListStringValue.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListStringValue {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListStringValue): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListStringValue>, I>>(base?: I): ListStringValue {
    return ListStringValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListStringValue>, I>>(object: I): ListStringValue {
    const message = createBaseListStringValue();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

/**
 * ServiceInvocation service is used to exchange the data between
 * caller dapr runtime and callee dapr runtime.
 *
 * The request message includes caller's HTTP/gRPC request
 * and deliver callee's response including status code.
 * The response status of rpc methods represents of internal gRPC
 * connection status, not callee's response status.
 *
 * Thus, ServiceInvocation gRPC response returns OK in most cases
 * regardless of callee's response.
 */
export type ServiceInvocationService = typeof ServiceInvocationService;
export const ServiceInvocationService = {
  /** Invokes a method of the specific actor. */
  callActor: {
    path: "/dapr.proto.internals.v1.ServiceInvocation/CallActor",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InternalInvokeRequest) => Buffer.from(InternalInvokeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InternalInvokeRequest.decode(value),
    responseSerialize: (value: InternalInvokeResponse) => Buffer.from(InternalInvokeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InternalInvokeResponse.decode(value),
  },
  /** Invokes a method of the specific service. */
  callLocal: {
    path: "/dapr.proto.internals.v1.ServiceInvocation/CallLocal",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InternalInvokeRequest) => Buffer.from(InternalInvokeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InternalInvokeRequest.decode(value),
    responseSerialize: (value: InternalInvokeResponse) => Buffer.from(InternalInvokeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InternalInvokeResponse.decode(value),
  },
  /**
   * Invokes a method of the specific service using a stream of data.
   * Although this uses a bi-directional stream, it behaves as a "simple RPC" in which the caller sends the full request (chunked in multiple messages in the stream), then reads the full response (chunked in the stream).
   * Each message in the stream contains a `InternalInvokeRequestStream` (for caller) or `InternalInvokeResponseStream` (for callee):
   * - The first message in the stream MUST contain a `request` (caller) or `response` (callee) message with all required properties present.
   * - The first message in the stream MAY contain a `payload`, which is not required and may be empty.
   * - Subsequent messages (any message except the first one in the stream) MUST contain a `payload` and MUST NOT contain any other property (like `request` or `response`).
   * - Each message with a `payload` MUST contain a sequence number in `seq`, which is a counter that starts from 0 and MUST be incremented by 1 in each chunk. The `seq` counter MUST NOT be included if the message does not have a `payload`.
   * - When the sender has completed sending the data, it MUST call `CloseSend` on the stream.
   * The caller and callee must send at least one message in the stream. If only 1 message is sent in each direction, that message must contain both a `request`/`response` (the `payload` may be empty).
   */
  callLocalStream: {
    path: "/dapr.proto.internals.v1.ServiceInvocation/CallLocalStream",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: InternalInvokeRequestStream) =>
      Buffer.from(InternalInvokeRequestStream.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InternalInvokeRequestStream.decode(value),
    responseSerialize: (value: InternalInvokeResponseStream) =>
      Buffer.from(InternalInvokeResponseStream.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InternalInvokeResponseStream.decode(value),
  },
} as const;

export interface ServiceInvocationServer extends UntypedServiceImplementation {
  /** Invokes a method of the specific actor. */
  callActor: handleUnaryCall<InternalInvokeRequest, InternalInvokeResponse>;
  /** Invokes a method of the specific service. */
  callLocal: handleUnaryCall<InternalInvokeRequest, InternalInvokeResponse>;
  /**
   * Invokes a method of the specific service using a stream of data.
   * Although this uses a bi-directional stream, it behaves as a "simple RPC" in which the caller sends the full request (chunked in multiple messages in the stream), then reads the full response (chunked in the stream).
   * Each message in the stream contains a `InternalInvokeRequestStream` (for caller) or `InternalInvokeResponseStream` (for callee):
   * - The first message in the stream MUST contain a `request` (caller) or `response` (callee) message with all required properties present.
   * - The first message in the stream MAY contain a `payload`, which is not required and may be empty.
   * - Subsequent messages (any message except the first one in the stream) MUST contain a `payload` and MUST NOT contain any other property (like `request` or `response`).
   * - Each message with a `payload` MUST contain a sequence number in `seq`, which is a counter that starts from 0 and MUST be incremented by 1 in each chunk. The `seq` counter MUST NOT be included if the message does not have a `payload`.
   * - When the sender has completed sending the data, it MUST call `CloseSend` on the stream.
   * The caller and callee must send at least one message in the stream. If only 1 message is sent in each direction, that message must contain both a `request`/`response` (the `payload` may be empty).
   */
  callLocalStream: handleBidiStreamingCall<InternalInvokeRequestStream, InternalInvokeResponseStream>;
}

export interface ServiceInvocationClient extends Client {
  /** Invokes a method of the specific actor. */
  callActor(
    request: InternalInvokeRequest,
    callback: (error: ServiceError | null, response: InternalInvokeResponse) => void,
  ): ClientUnaryCall;
  callActor(
    request: InternalInvokeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InternalInvokeResponse) => void,
  ): ClientUnaryCall;
  callActor(
    request: InternalInvokeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InternalInvokeResponse) => void,
  ): ClientUnaryCall;
  /** Invokes a method of the specific service. */
  callLocal(
    request: InternalInvokeRequest,
    callback: (error: ServiceError | null, response: InternalInvokeResponse) => void,
  ): ClientUnaryCall;
  callLocal(
    request: InternalInvokeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InternalInvokeResponse) => void,
  ): ClientUnaryCall;
  callLocal(
    request: InternalInvokeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InternalInvokeResponse) => void,
  ): ClientUnaryCall;
  /**
   * Invokes a method of the specific service using a stream of data.
   * Although this uses a bi-directional stream, it behaves as a "simple RPC" in which the caller sends the full request (chunked in multiple messages in the stream), then reads the full response (chunked in the stream).
   * Each message in the stream contains a `InternalInvokeRequestStream` (for caller) or `InternalInvokeResponseStream` (for callee):
   * - The first message in the stream MUST contain a `request` (caller) or `response` (callee) message with all required properties present.
   * - The first message in the stream MAY contain a `payload`, which is not required and may be empty.
   * - Subsequent messages (any message except the first one in the stream) MUST contain a `payload` and MUST NOT contain any other property (like `request` or `response`).
   * - Each message with a `payload` MUST contain a sequence number in `seq`, which is a counter that starts from 0 and MUST be incremented by 1 in each chunk. The `seq` counter MUST NOT be included if the message does not have a `payload`.
   * - When the sender has completed sending the data, it MUST call `CloseSend` on the stream.
   * The caller and callee must send at least one message in the stream. If only 1 message is sent in each direction, that message must contain both a `request`/`response` (the `payload` may be empty).
   */
  callLocalStream(): ClientDuplexStream<InternalInvokeRequestStream, InternalInvokeResponseStream>;
  callLocalStream(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<InternalInvokeRequestStream, InternalInvokeResponseStream>;
  callLocalStream(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<InternalInvokeRequestStream, InternalInvokeResponseStream>;
}

export const ServiceInvocationClient = makeGenericClientConstructor(
  ServiceInvocationService,
  "dapr.proto.internals.v1.ServiceInvocation",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ServiceInvocationClient;
  service: typeof ServiceInvocationService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
