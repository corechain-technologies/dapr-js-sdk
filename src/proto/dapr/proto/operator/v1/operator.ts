// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.19.1
// source: dapr/proto/operator/v1/operator.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Empty } from "../../../../google/protobuf/empty";

export const protobufPackage = "dapr.proto.operator.v1";

/** ListComponentsRequest is the request to get components for a sidecar in namespace. */
export interface ListComponentsRequest {
  namespace: string;
  podName: string;
}

/** ComponentUpdateRequest is the request to get updates about new components for a given namespace. */
export interface ComponentUpdateRequest {
  namespace: string;
  podName: string;
}

/** ComponentUpdateEvent includes the updated component event. */
export interface ComponentUpdateEvent {
  component: Uint8Array;
}

/** ListComponentResponse includes the list of available components. */
export interface ListComponentResponse {
  components: Uint8Array[];
}

/** GetConfigurationRequest is the request message to get the configuration. */
export interface GetConfigurationRequest {
  name: string;
  namespace: string;
  podName: string;
}

/** GetConfigurationResponse includes the requested configuration. */
export interface GetConfigurationResponse {
  configuration: Uint8Array;
}

/** ListSubscriptionsResponse includes pub/sub subscriptions. */
export interface ListSubscriptionsResponse {
  subscriptions: Uint8Array[];
}

/** GetResiliencyRequest is the request to get a resiliency configuration. */
export interface GetResiliencyRequest {
  name: string;
  namespace: string;
}

/** GetResiliencyResponse includes the requested resiliency configuration. */
export interface GetResiliencyResponse {
  resiliency: Uint8Array;
}

/** ListResiliencyRequest is the requests to get resiliency configurations for a sidecar namespace. */
export interface ListResiliencyRequest {
  namespace: string;
}

/** ListResiliencyResponse includes the list of available resiliency configurations. */
export interface ListResiliencyResponse {
  resiliencies: Uint8Array[];
}

export interface ListSubscriptionsRequest {
  podName: string;
  namespace: string;
}

/** GetHTTPEndpointRequest is the request to get an http endpoint configuration. */
export interface GetHTTPEndpointRequest {
  name: string;
  namespace: string;
}

/** GetHTTPEndpointResponse includes the requested http endpoint configuration. */
export interface GetHTTPEndpointResponse {
  httpEndpoint: Uint8Array;
}

/** ListHTTPEndpointsResponse includes the list of available http endpoint configurations. */
export interface ListHTTPEndpointsResponse {
  httpEndpoints: Uint8Array[];
}

export interface ListHTTPEndpointsRequest {
  namespace: string;
}

/** HTTPEndpointsUpdateRequest is the request to get updates about new http endpoints for a given namespace. */
export interface HTTPEndpointUpdateRequest {
  namespace: string;
  podName: string;
}

/** HTTPEndpointsUpdateEvent includes the updated http endpoint event. */
export interface HTTPEndpointUpdateEvent {
  httpEndpoints: Uint8Array;
}

function createBaseListComponentsRequest(): ListComponentsRequest {
  return { namespace: "", podName: "" };
}

export const ListComponentsRequest = {
  encode(message: ListComponentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.podName !== "") {
      writer.uint32(18).string(message.podName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListComponentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListComponentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.podName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListComponentsRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListComponentsRequest | ListComponentsRequest[]>
      | Iterable<ListComponentsRequest | ListComponentsRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListComponentsRequest.encode(p).finish()];
        }
      } else {
        yield* [ListComponentsRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListComponentsRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListComponentsRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListComponentsRequest.decode(p)];
        }
      } else {
        yield* [ListComponentsRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListComponentsRequest {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      podName: isSet(object.podName) ? globalThis.String(object.podName) : "",
    };
  },

  toJSON(message: ListComponentsRequest): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.podName !== "") {
      obj.podName = message.podName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListComponentsRequest>, I>>(base?: I): ListComponentsRequest {
    return ListComponentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListComponentsRequest>, I>>(object: I): ListComponentsRequest {
    const message = createBaseListComponentsRequest();
    message.namespace = object.namespace ?? "";
    message.podName = object.podName ?? "";
    return message;
  },
};

function createBaseComponentUpdateRequest(): ComponentUpdateRequest {
  return { namespace: "", podName: "" };
}

export const ComponentUpdateRequest = {
  encode(message: ComponentUpdateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.podName !== "") {
      writer.uint32(18).string(message.podName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComponentUpdateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponentUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.podName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ComponentUpdateRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ComponentUpdateRequest | ComponentUpdateRequest[]>
      | Iterable<ComponentUpdateRequest | ComponentUpdateRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ComponentUpdateRequest.encode(p).finish()];
        }
      } else {
        yield* [ComponentUpdateRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ComponentUpdateRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ComponentUpdateRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ComponentUpdateRequest.decode(p)];
        }
      } else {
        yield* [ComponentUpdateRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ComponentUpdateRequest {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      podName: isSet(object.podName) ? globalThis.String(object.podName) : "",
    };
  },

  toJSON(message: ComponentUpdateRequest): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.podName !== "") {
      obj.podName = message.podName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComponentUpdateRequest>, I>>(base?: I): ComponentUpdateRequest {
    return ComponentUpdateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComponentUpdateRequest>, I>>(object: I): ComponentUpdateRequest {
    const message = createBaseComponentUpdateRequest();
    message.namespace = object.namespace ?? "";
    message.podName = object.podName ?? "";
    return message;
  },
};

function createBaseComponentUpdateEvent(): ComponentUpdateEvent {
  return { component: new Uint8Array(0) };
}

export const ComponentUpdateEvent = {
  encode(message: ComponentUpdateEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.component.length !== 0) {
      writer.uint32(10).bytes(message.component);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComponentUpdateEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponentUpdateEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.component = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ComponentUpdateEvent, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ComponentUpdateEvent | ComponentUpdateEvent[]>
      | Iterable<ComponentUpdateEvent | ComponentUpdateEvent[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ComponentUpdateEvent.encode(p).finish()];
        }
      } else {
        yield* [ComponentUpdateEvent.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ComponentUpdateEvent>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ComponentUpdateEvent> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ComponentUpdateEvent.decode(p)];
        }
      } else {
        yield* [ComponentUpdateEvent.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ComponentUpdateEvent {
    return { component: isSet(object.component) ? bytesFromBase64(object.component) : new Uint8Array(0) };
  },

  toJSON(message: ComponentUpdateEvent): unknown {
    const obj: any = {};
    if (message.component.length !== 0) {
      obj.component = base64FromBytes(message.component);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComponentUpdateEvent>, I>>(base?: I): ComponentUpdateEvent {
    return ComponentUpdateEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComponentUpdateEvent>, I>>(object: I): ComponentUpdateEvent {
    const message = createBaseComponentUpdateEvent();
    message.component = object.component ?? new Uint8Array(0);
    return message;
  },
};

function createBaseListComponentResponse(): ListComponentResponse {
  return { components: [] };
}

export const ListComponentResponse = {
  encode(message: ListComponentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.components) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListComponentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListComponentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.components.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListComponentResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListComponentResponse | ListComponentResponse[]>
      | Iterable<ListComponentResponse | ListComponentResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListComponentResponse.encode(p).finish()];
        }
      } else {
        yield* [ListComponentResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListComponentResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListComponentResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListComponentResponse.decode(p)];
        }
      } else {
        yield* [ListComponentResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListComponentResponse {
    return {
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: ListComponentResponse): unknown {
    const obj: any = {};
    if (message.components?.length) {
      obj.components = message.components.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListComponentResponse>, I>>(base?: I): ListComponentResponse {
    return ListComponentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListComponentResponse>, I>>(object: I): ListComponentResponse {
    const message = createBaseListComponentResponse();
    message.components = object.components?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetConfigurationRequest(): GetConfigurationRequest {
  return { name: "", namespace: "", podName: "" };
}

export const GetConfigurationRequest = {
  encode(message: GetConfigurationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.podName !== "") {
      writer.uint32(26).string(message.podName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConfigurationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigurationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.podName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetConfigurationRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<GetConfigurationRequest | GetConfigurationRequest[]>
      | Iterable<GetConfigurationRequest | GetConfigurationRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetConfigurationRequest.encode(p).finish()];
        }
      } else {
        yield* [GetConfigurationRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetConfigurationRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetConfigurationRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetConfigurationRequest.decode(p)];
        }
      } else {
        yield* [GetConfigurationRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetConfigurationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      podName: isSet(object.podName) ? globalThis.String(object.podName) : "",
    };
  },

  toJSON(message: GetConfigurationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.podName !== "") {
      obj.podName = message.podName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConfigurationRequest>, I>>(base?: I): GetConfigurationRequest {
    return GetConfigurationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConfigurationRequest>, I>>(object: I): GetConfigurationRequest {
    const message = createBaseGetConfigurationRequest();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.podName = object.podName ?? "";
    return message;
  },
};

function createBaseGetConfigurationResponse(): GetConfigurationResponse {
  return { configuration: new Uint8Array(0) };
}

export const GetConfigurationResponse = {
  encode(message: GetConfigurationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.configuration.length !== 0) {
      writer.uint32(10).bytes(message.configuration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConfigurationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigurationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.configuration = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetConfigurationResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<GetConfigurationResponse | GetConfigurationResponse[]>
      | Iterable<GetConfigurationResponse | GetConfigurationResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetConfigurationResponse.encode(p).finish()];
        }
      } else {
        yield* [GetConfigurationResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetConfigurationResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetConfigurationResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetConfigurationResponse.decode(p)];
        }
      } else {
        yield* [GetConfigurationResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetConfigurationResponse {
    return { configuration: isSet(object.configuration) ? bytesFromBase64(object.configuration) : new Uint8Array(0) };
  },

  toJSON(message: GetConfigurationResponse): unknown {
    const obj: any = {};
    if (message.configuration.length !== 0) {
      obj.configuration = base64FromBytes(message.configuration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConfigurationResponse>, I>>(base?: I): GetConfigurationResponse {
    return GetConfigurationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConfigurationResponse>, I>>(object: I): GetConfigurationResponse {
    const message = createBaseGetConfigurationResponse();
    message.configuration = object.configuration ?? new Uint8Array(0);
    return message;
  },
};

function createBaseListSubscriptionsResponse(): ListSubscriptionsResponse {
  return { subscriptions: [] };
}

export const ListSubscriptionsResponse = {
  encode(message: ListSubscriptionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.subscriptions) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSubscriptionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListSubscriptionsResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListSubscriptionsResponse | ListSubscriptionsResponse[]>
      | Iterable<ListSubscriptionsResponse | ListSubscriptionsResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListSubscriptionsResponse.encode(p).finish()];
        }
      } else {
        yield* [ListSubscriptionsResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListSubscriptionsResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListSubscriptionsResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListSubscriptionsResponse.decode(p)];
        }
      } else {
        yield* [ListSubscriptionsResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListSubscriptionsResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: ListSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSubscriptionsResponse>, I>>(base?: I): ListSubscriptionsResponse {
    return ListSubscriptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSubscriptionsResponse>, I>>(object: I): ListSubscriptionsResponse {
    const message = createBaseListSubscriptionsResponse();
    message.subscriptions = object.subscriptions?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetResiliencyRequest(): GetResiliencyRequest {
  return { name: "", namespace: "" };
}

export const GetResiliencyRequest = {
  encode(message: GetResiliencyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetResiliencyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResiliencyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetResiliencyRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<GetResiliencyRequest | GetResiliencyRequest[]>
      | Iterable<GetResiliencyRequest | GetResiliencyRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetResiliencyRequest.encode(p).finish()];
        }
      } else {
        yield* [GetResiliencyRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetResiliencyRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetResiliencyRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetResiliencyRequest.decode(p)];
        }
      } else {
        yield* [GetResiliencyRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetResiliencyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
    };
  },

  toJSON(message: GetResiliencyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResiliencyRequest>, I>>(base?: I): GetResiliencyRequest {
    return GetResiliencyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResiliencyRequest>, I>>(object: I): GetResiliencyRequest {
    const message = createBaseGetResiliencyRequest();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    return message;
  },
};

function createBaseGetResiliencyResponse(): GetResiliencyResponse {
  return { resiliency: new Uint8Array(0) };
}

export const GetResiliencyResponse = {
  encode(message: GetResiliencyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resiliency.length !== 0) {
      writer.uint32(10).bytes(message.resiliency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetResiliencyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResiliencyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resiliency = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetResiliencyResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<GetResiliencyResponse | GetResiliencyResponse[]>
      | Iterable<GetResiliencyResponse | GetResiliencyResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetResiliencyResponse.encode(p).finish()];
        }
      } else {
        yield* [GetResiliencyResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetResiliencyResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetResiliencyResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetResiliencyResponse.decode(p)];
        }
      } else {
        yield* [GetResiliencyResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetResiliencyResponse {
    return { resiliency: isSet(object.resiliency) ? bytesFromBase64(object.resiliency) : new Uint8Array(0) };
  },

  toJSON(message: GetResiliencyResponse): unknown {
    const obj: any = {};
    if (message.resiliency.length !== 0) {
      obj.resiliency = base64FromBytes(message.resiliency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResiliencyResponse>, I>>(base?: I): GetResiliencyResponse {
    return GetResiliencyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResiliencyResponse>, I>>(object: I): GetResiliencyResponse {
    const message = createBaseGetResiliencyResponse();
    message.resiliency = object.resiliency ?? new Uint8Array(0);
    return message;
  },
};

function createBaseListResiliencyRequest(): ListResiliencyRequest {
  return { namespace: "" };
}

export const ListResiliencyRequest = {
  encode(message: ListResiliencyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListResiliencyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListResiliencyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListResiliencyRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListResiliencyRequest | ListResiliencyRequest[]>
      | Iterable<ListResiliencyRequest | ListResiliencyRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListResiliencyRequest.encode(p).finish()];
        }
      } else {
        yield* [ListResiliencyRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListResiliencyRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListResiliencyRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListResiliencyRequest.decode(p)];
        }
      } else {
        yield* [ListResiliencyRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListResiliencyRequest {
    return { namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "" };
  },

  toJSON(message: ListResiliencyRequest): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListResiliencyRequest>, I>>(base?: I): ListResiliencyRequest {
    return ListResiliencyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListResiliencyRequest>, I>>(object: I): ListResiliencyRequest {
    const message = createBaseListResiliencyRequest();
    message.namespace = object.namespace ?? "";
    return message;
  },
};

function createBaseListResiliencyResponse(): ListResiliencyResponse {
  return { resiliencies: [] };
}

export const ListResiliencyResponse = {
  encode(message: ListResiliencyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.resiliencies) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListResiliencyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListResiliencyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resiliencies.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListResiliencyResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListResiliencyResponse | ListResiliencyResponse[]>
      | Iterable<ListResiliencyResponse | ListResiliencyResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListResiliencyResponse.encode(p).finish()];
        }
      } else {
        yield* [ListResiliencyResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListResiliencyResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListResiliencyResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListResiliencyResponse.decode(p)];
        }
      } else {
        yield* [ListResiliencyResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListResiliencyResponse {
    return {
      resiliencies: globalThis.Array.isArray(object?.resiliencies)
        ? object.resiliencies.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: ListResiliencyResponse): unknown {
    const obj: any = {};
    if (message.resiliencies?.length) {
      obj.resiliencies = message.resiliencies.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListResiliencyResponse>, I>>(base?: I): ListResiliencyResponse {
    return ListResiliencyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListResiliencyResponse>, I>>(object: I): ListResiliencyResponse {
    const message = createBaseListResiliencyResponse();
    message.resiliencies = object.resiliencies?.map((e) => e) || [];
    return message;
  },
};

function createBaseListSubscriptionsRequest(): ListSubscriptionsRequest {
  return { podName: "", namespace: "" };
}

export const ListSubscriptionsRequest = {
  encode(message: ListSubscriptionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.podName !== "") {
      writer.uint32(10).string(message.podName);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSubscriptionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.podName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListSubscriptionsRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListSubscriptionsRequest | ListSubscriptionsRequest[]>
      | Iterable<ListSubscriptionsRequest | ListSubscriptionsRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListSubscriptionsRequest.encode(p).finish()];
        }
      } else {
        yield* [ListSubscriptionsRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListSubscriptionsRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListSubscriptionsRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListSubscriptionsRequest.decode(p)];
        }
      } else {
        yield* [ListSubscriptionsRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListSubscriptionsRequest {
    return {
      podName: isSet(object.podName) ? globalThis.String(object.podName) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
    };
  },

  toJSON(message: ListSubscriptionsRequest): unknown {
    const obj: any = {};
    if (message.podName !== "") {
      obj.podName = message.podName;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSubscriptionsRequest>, I>>(base?: I): ListSubscriptionsRequest {
    return ListSubscriptionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSubscriptionsRequest>, I>>(object: I): ListSubscriptionsRequest {
    const message = createBaseListSubscriptionsRequest();
    message.podName = object.podName ?? "";
    message.namespace = object.namespace ?? "";
    return message;
  },
};

function createBaseGetHTTPEndpointRequest(): GetHTTPEndpointRequest {
  return { name: "", namespace: "" };
}

export const GetHTTPEndpointRequest = {
  encode(message: GetHTTPEndpointRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHTTPEndpointRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHTTPEndpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetHTTPEndpointRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<GetHTTPEndpointRequest | GetHTTPEndpointRequest[]>
      | Iterable<GetHTTPEndpointRequest | GetHTTPEndpointRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetHTTPEndpointRequest.encode(p).finish()];
        }
      } else {
        yield* [GetHTTPEndpointRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetHTTPEndpointRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetHTTPEndpointRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetHTTPEndpointRequest.decode(p)];
        }
      } else {
        yield* [GetHTTPEndpointRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetHTTPEndpointRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
    };
  },

  toJSON(message: GetHTTPEndpointRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHTTPEndpointRequest>, I>>(base?: I): GetHTTPEndpointRequest {
    return GetHTTPEndpointRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHTTPEndpointRequest>, I>>(object: I): GetHTTPEndpointRequest {
    const message = createBaseGetHTTPEndpointRequest();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    return message;
  },
};

function createBaseGetHTTPEndpointResponse(): GetHTTPEndpointResponse {
  return { httpEndpoint: new Uint8Array(0) };
}

export const GetHTTPEndpointResponse = {
  encode(message: GetHTTPEndpointResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.httpEndpoint.length !== 0) {
      writer.uint32(10).bytes(message.httpEndpoint);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHTTPEndpointResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHTTPEndpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.httpEndpoint = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<GetHTTPEndpointResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<GetHTTPEndpointResponse | GetHTTPEndpointResponse[]>
      | Iterable<GetHTTPEndpointResponse | GetHTTPEndpointResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetHTTPEndpointResponse.encode(p).finish()];
        }
      } else {
        yield* [GetHTTPEndpointResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, GetHTTPEndpointResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<GetHTTPEndpointResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [GetHTTPEndpointResponse.decode(p)];
        }
      } else {
        yield* [GetHTTPEndpointResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): GetHTTPEndpointResponse {
    return { httpEndpoint: isSet(object.httpEndpoint) ? bytesFromBase64(object.httpEndpoint) : new Uint8Array(0) };
  },

  toJSON(message: GetHTTPEndpointResponse): unknown {
    const obj: any = {};
    if (message.httpEndpoint.length !== 0) {
      obj.httpEndpoint = base64FromBytes(message.httpEndpoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHTTPEndpointResponse>, I>>(base?: I): GetHTTPEndpointResponse {
    return GetHTTPEndpointResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHTTPEndpointResponse>, I>>(object: I): GetHTTPEndpointResponse {
    const message = createBaseGetHTTPEndpointResponse();
    message.httpEndpoint = object.httpEndpoint ?? new Uint8Array(0);
    return message;
  },
};

function createBaseListHTTPEndpointsResponse(): ListHTTPEndpointsResponse {
  return { httpEndpoints: [] };
}

export const ListHTTPEndpointsResponse = {
  encode(message: ListHTTPEndpointsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.httpEndpoints) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListHTTPEndpointsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHTTPEndpointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.httpEndpoints.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListHTTPEndpointsResponse, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListHTTPEndpointsResponse | ListHTTPEndpointsResponse[]>
      | Iterable<ListHTTPEndpointsResponse | ListHTTPEndpointsResponse[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListHTTPEndpointsResponse.encode(p).finish()];
        }
      } else {
        yield* [ListHTTPEndpointsResponse.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListHTTPEndpointsResponse>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListHTTPEndpointsResponse> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListHTTPEndpointsResponse.decode(p)];
        }
      } else {
        yield* [ListHTTPEndpointsResponse.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListHTTPEndpointsResponse {
    return {
      httpEndpoints: globalThis.Array.isArray(object?.httpEndpoints)
        ? object.httpEndpoints.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: ListHTTPEndpointsResponse): unknown {
    const obj: any = {};
    if (message.httpEndpoints?.length) {
      obj.httpEndpoints = message.httpEndpoints.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListHTTPEndpointsResponse>, I>>(base?: I): ListHTTPEndpointsResponse {
    return ListHTTPEndpointsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListHTTPEndpointsResponse>, I>>(object: I): ListHTTPEndpointsResponse {
    const message = createBaseListHTTPEndpointsResponse();
    message.httpEndpoints = object.httpEndpoints?.map((e) => e) || [];
    return message;
  },
};

function createBaseListHTTPEndpointsRequest(): ListHTTPEndpointsRequest {
  return { namespace: "" };
}

export const ListHTTPEndpointsRequest = {
  encode(message: ListHTTPEndpointsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListHTTPEndpointsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHTTPEndpointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<ListHTTPEndpointsRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<ListHTTPEndpointsRequest | ListHTTPEndpointsRequest[]>
      | Iterable<ListHTTPEndpointsRequest | ListHTTPEndpointsRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListHTTPEndpointsRequest.encode(p).finish()];
        }
      } else {
        yield* [ListHTTPEndpointsRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, ListHTTPEndpointsRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<ListHTTPEndpointsRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [ListHTTPEndpointsRequest.decode(p)];
        }
      } else {
        yield* [ListHTTPEndpointsRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): ListHTTPEndpointsRequest {
    return { namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "" };
  },

  toJSON(message: ListHTTPEndpointsRequest): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListHTTPEndpointsRequest>, I>>(base?: I): ListHTTPEndpointsRequest {
    return ListHTTPEndpointsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListHTTPEndpointsRequest>, I>>(object: I): ListHTTPEndpointsRequest {
    const message = createBaseListHTTPEndpointsRequest();
    message.namespace = object.namespace ?? "";
    return message;
  },
};

function createBaseHTTPEndpointUpdateRequest(): HTTPEndpointUpdateRequest {
  return { namespace: "", podName: "" };
}

export const HTTPEndpointUpdateRequest = {
  encode(message: HTTPEndpointUpdateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.podName !== "") {
      writer.uint32(18).string(message.podName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HTTPEndpointUpdateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPEndpointUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.podName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<HTTPEndpointUpdateRequest, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<HTTPEndpointUpdateRequest | HTTPEndpointUpdateRequest[]>
      | Iterable<HTTPEndpointUpdateRequest | HTTPEndpointUpdateRequest[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [HTTPEndpointUpdateRequest.encode(p).finish()];
        }
      } else {
        yield* [HTTPEndpointUpdateRequest.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, HTTPEndpointUpdateRequest>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<HTTPEndpointUpdateRequest> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [HTTPEndpointUpdateRequest.decode(p)];
        }
      } else {
        yield* [HTTPEndpointUpdateRequest.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): HTTPEndpointUpdateRequest {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      podName: isSet(object.podName) ? globalThis.String(object.podName) : "",
    };
  },

  toJSON(message: HTTPEndpointUpdateRequest): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.podName !== "") {
      obj.podName = message.podName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTTPEndpointUpdateRequest>, I>>(base?: I): HTTPEndpointUpdateRequest {
    return HTTPEndpointUpdateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTTPEndpointUpdateRequest>, I>>(object: I): HTTPEndpointUpdateRequest {
    const message = createBaseHTTPEndpointUpdateRequest();
    message.namespace = object.namespace ?? "";
    message.podName = object.podName ?? "";
    return message;
  },
};

function createBaseHTTPEndpointUpdateEvent(): HTTPEndpointUpdateEvent {
  return { httpEndpoints: new Uint8Array(0) };
}

export const HTTPEndpointUpdateEvent = {
  encode(message: HTTPEndpointUpdateEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.httpEndpoints.length !== 0) {
      writer.uint32(10).bytes(message.httpEndpoints);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HTTPEndpointUpdateEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPEndpointUpdateEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.httpEndpoints = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  // encodeTransform encodes a source of message objects.
  // Transform<HTTPEndpointUpdateEvent, Uint8Array>
  async *encodeTransform(
    source:
      | AsyncIterable<HTTPEndpointUpdateEvent | HTTPEndpointUpdateEvent[]>
      | Iterable<HTTPEndpointUpdateEvent | HTTPEndpointUpdateEvent[]>,
  ): AsyncIterable<Uint8Array> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [HTTPEndpointUpdateEvent.encode(p).finish()];
        }
      } else {
        yield* [HTTPEndpointUpdateEvent.encode(pkt as any).finish()];
      }
    }
  },

  // decodeTransform decodes a source of encoded messages.
  // Transform<Uint8Array, HTTPEndpointUpdateEvent>
  async *decodeTransform(
    source: AsyncIterable<Uint8Array | Uint8Array[]> | Iterable<Uint8Array | Uint8Array[]>,
  ): AsyncIterable<HTTPEndpointUpdateEvent> {
    for await (const pkt of source) {
      if (globalThis.Array.isArray(pkt)) {
        for (const p of (pkt as any)) {
          yield* [HTTPEndpointUpdateEvent.decode(p)];
        }
      } else {
        yield* [HTTPEndpointUpdateEvent.decode(pkt as any)];
      }
    }
  },

  fromJSON(object: any): HTTPEndpointUpdateEvent {
    return { httpEndpoints: isSet(object.httpEndpoints) ? bytesFromBase64(object.httpEndpoints) : new Uint8Array(0) };
  },

  toJSON(message: HTTPEndpointUpdateEvent): unknown {
    const obj: any = {};
    if (message.httpEndpoints.length !== 0) {
      obj.httpEndpoints = base64FromBytes(message.httpEndpoints);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTTPEndpointUpdateEvent>, I>>(base?: I): HTTPEndpointUpdateEvent {
    return HTTPEndpointUpdateEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTTPEndpointUpdateEvent>, I>>(object: I): HTTPEndpointUpdateEvent {
    const message = createBaseHTTPEndpointUpdateEvent();
    message.httpEndpoints = object.httpEndpoints ?? new Uint8Array(0);
    return message;
  },
};

export type OperatorService = typeof OperatorService;
export const OperatorService = {
  /** Sends events to Dapr sidecars upon component changes. */
  componentUpdate: {
    path: "/dapr.proto.operator.v1.Operator/ComponentUpdate",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ComponentUpdateRequest) => Buffer.from(ComponentUpdateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ComponentUpdateRequest.decode(value),
    responseSerialize: (value: ComponentUpdateEvent) => Buffer.from(ComponentUpdateEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ComponentUpdateEvent.decode(value),
  },
  /** Returns a list of available components */
  listComponents: {
    path: "/dapr.proto.operator.v1.Operator/ListComponents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListComponentsRequest) => Buffer.from(ListComponentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListComponentsRequest.decode(value),
    responseSerialize: (value: ListComponentResponse) => Buffer.from(ListComponentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListComponentResponse.decode(value),
  },
  /** Returns a given configuration by name */
  getConfiguration: {
    path: "/dapr.proto.operator.v1.Operator/GetConfiguration",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConfigurationRequest) => Buffer.from(GetConfigurationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetConfigurationRequest.decode(value),
    responseSerialize: (value: GetConfigurationResponse) =>
      Buffer.from(GetConfigurationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetConfigurationResponse.decode(value),
  },
  /** Returns a list of pub/sub subscriptions */
  listSubscriptions: {
    path: "/dapr.proto.operator.v1.Operator/ListSubscriptions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ListSubscriptionsResponse) =>
      Buffer.from(ListSubscriptionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListSubscriptionsResponse.decode(value),
  },
  /** Returns a given resiliency configuration by name */
  getResiliency: {
    path: "/dapr.proto.operator.v1.Operator/GetResiliency",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetResiliencyRequest) => Buffer.from(GetResiliencyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetResiliencyRequest.decode(value),
    responseSerialize: (value: GetResiliencyResponse) => Buffer.from(GetResiliencyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetResiliencyResponse.decode(value),
  },
  /** Returns a list of resiliency configurations */
  listResiliency: {
    path: "/dapr.proto.operator.v1.Operator/ListResiliency",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListResiliencyRequest) => Buffer.from(ListResiliencyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListResiliencyRequest.decode(value),
    responseSerialize: (value: ListResiliencyResponse) => Buffer.from(ListResiliencyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListResiliencyResponse.decode(value),
  },
  /** Returns a list of pub/sub subscriptions, ListSubscriptionsRequest to expose pod info */
  listSubscriptionsV2: {
    path: "/dapr.proto.operator.v1.Operator/ListSubscriptionsV2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSubscriptionsRequest) => Buffer.from(ListSubscriptionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListSubscriptionsRequest.decode(value),
    responseSerialize: (value: ListSubscriptionsResponse) =>
      Buffer.from(ListSubscriptionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListSubscriptionsResponse.decode(value),
  },
  /** Returns a list of http endpoints */
  listHttpEndpoints: {
    path: "/dapr.proto.operator.v1.Operator/ListHTTPEndpoints",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListHTTPEndpointsRequest) => Buffer.from(ListHTTPEndpointsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListHTTPEndpointsRequest.decode(value),
    responseSerialize: (value: ListHTTPEndpointsResponse) =>
      Buffer.from(ListHTTPEndpointsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListHTTPEndpointsResponse.decode(value),
  },
  /** Sends events to Dapr sidecars upon http endpoint changes. */
  httpEndpointUpdate: {
    path: "/dapr.proto.operator.v1.Operator/HTTPEndpointUpdate",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: HTTPEndpointUpdateRequest) =>
      Buffer.from(HTTPEndpointUpdateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HTTPEndpointUpdateRequest.decode(value),
    responseSerialize: (value: HTTPEndpointUpdateEvent) => Buffer.from(HTTPEndpointUpdateEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HTTPEndpointUpdateEvent.decode(value),
  },
} as const;

export interface OperatorServer extends UntypedServiceImplementation {
  /** Sends events to Dapr sidecars upon component changes. */
  componentUpdate: handleServerStreamingCall<ComponentUpdateRequest, ComponentUpdateEvent>;
  /** Returns a list of available components */
  listComponents: handleUnaryCall<ListComponentsRequest, ListComponentResponse>;
  /** Returns a given configuration by name */
  getConfiguration: handleUnaryCall<GetConfigurationRequest, GetConfigurationResponse>;
  /** Returns a list of pub/sub subscriptions */
  listSubscriptions: handleUnaryCall<Empty, ListSubscriptionsResponse>;
  /** Returns a given resiliency configuration by name */
  getResiliency: handleUnaryCall<GetResiliencyRequest, GetResiliencyResponse>;
  /** Returns a list of resiliency configurations */
  listResiliency: handleUnaryCall<ListResiliencyRequest, ListResiliencyResponse>;
  /** Returns a list of pub/sub subscriptions, ListSubscriptionsRequest to expose pod info */
  listSubscriptionsV2: handleUnaryCall<ListSubscriptionsRequest, ListSubscriptionsResponse>;
  /** Returns a list of http endpoints */
  listHttpEndpoints: handleUnaryCall<ListHTTPEndpointsRequest, ListHTTPEndpointsResponse>;
  /** Sends events to Dapr sidecars upon http endpoint changes. */
  httpEndpointUpdate: handleServerStreamingCall<HTTPEndpointUpdateRequest, HTTPEndpointUpdateEvent>;
}

export interface OperatorClient extends Client {
  /** Sends events to Dapr sidecars upon component changes. */
  componentUpdate(
    request: ComponentUpdateRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ComponentUpdateEvent>;
  componentUpdate(
    request: ComponentUpdateRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ComponentUpdateEvent>;
  /** Returns a list of available components */
  listComponents(
    request: ListComponentsRequest,
    callback: (error: ServiceError | null, response: ListComponentResponse) => void,
  ): ClientUnaryCall;
  listComponents(
    request: ListComponentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListComponentResponse) => void,
  ): ClientUnaryCall;
  listComponents(
    request: ListComponentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListComponentResponse) => void,
  ): ClientUnaryCall;
  /** Returns a given configuration by name */
  getConfiguration(
    request: GetConfigurationRequest,
    callback: (error: ServiceError | null, response: GetConfigurationResponse) => void,
  ): ClientUnaryCall;
  getConfiguration(
    request: GetConfigurationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetConfigurationResponse) => void,
  ): ClientUnaryCall;
  getConfiguration(
    request: GetConfigurationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetConfigurationResponse) => void,
  ): ClientUnaryCall;
  /** Returns a list of pub/sub subscriptions */
  listSubscriptions(
    request: Empty,
    callback: (error: ServiceError | null, response: ListSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  listSubscriptions(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  listSubscriptions(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  /** Returns a given resiliency configuration by name */
  getResiliency(
    request: GetResiliencyRequest,
    callback: (error: ServiceError | null, response: GetResiliencyResponse) => void,
  ): ClientUnaryCall;
  getResiliency(
    request: GetResiliencyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetResiliencyResponse) => void,
  ): ClientUnaryCall;
  getResiliency(
    request: GetResiliencyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetResiliencyResponse) => void,
  ): ClientUnaryCall;
  /** Returns a list of resiliency configurations */
  listResiliency(
    request: ListResiliencyRequest,
    callback: (error: ServiceError | null, response: ListResiliencyResponse) => void,
  ): ClientUnaryCall;
  listResiliency(
    request: ListResiliencyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListResiliencyResponse) => void,
  ): ClientUnaryCall;
  listResiliency(
    request: ListResiliencyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListResiliencyResponse) => void,
  ): ClientUnaryCall;
  /** Returns a list of pub/sub subscriptions, ListSubscriptionsRequest to expose pod info */
  listSubscriptionsV2(
    request: ListSubscriptionsRequest,
    callback: (error: ServiceError | null, response: ListSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  listSubscriptionsV2(
    request: ListSubscriptionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  listSubscriptionsV2(
    request: ListSubscriptionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  /** Returns a list of http endpoints */
  listHttpEndpoints(
    request: ListHTTPEndpointsRequest,
    callback: (error: ServiceError | null, response: ListHTTPEndpointsResponse) => void,
  ): ClientUnaryCall;
  listHttpEndpoints(
    request: ListHTTPEndpointsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListHTTPEndpointsResponse) => void,
  ): ClientUnaryCall;
  listHttpEndpoints(
    request: ListHTTPEndpointsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListHTTPEndpointsResponse) => void,
  ): ClientUnaryCall;
  /** Sends events to Dapr sidecars upon http endpoint changes. */
  httpEndpointUpdate(
    request: HTTPEndpointUpdateRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<HTTPEndpointUpdateEvent>;
  httpEndpointUpdate(
    request: HTTPEndpointUpdateRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<HTTPEndpointUpdateEvent>;
}

export const OperatorClient = makeGenericClientConstructor(
  OperatorService,
  "dapr.proto.operator.v1.Operator",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OperatorClient;
  service: typeof OperatorService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
